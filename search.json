[
  {
    "objectID": "2023/day5_3.html",
    "href": "2023/day5_3.html",
    "title": "Test case: range 90-99 (length 10) with rule 98->50 (length 2)",
    "section": "",
    "text": "The almanac (your puzzle input) lists all of the seeds that need to be planted. It also lists what type of soil to use with each kind of seed, what type of fertilizer to use with each kind of soil, what type of water to use with each kind of fertilizer, and so on. Every type of seed, soil, fertilizer and so on is identified with a number, but numbers are reused by each category - that is, soil 123 and fertilizer 123 aren’t necessarily related to each other.\nFor example:\nseeds: 79 14 55 13\n\nseed-to-soil map:\n50 98 2\n52 50 48\n\nsoil-to-fertilizer map:\n0 15 37\n37 52 2\n39 0 15\n\nfertilizer-to-water map:\n49 53 8\n0 11 42\n42 0 7\n57 7 4\n\nwater-to-light map:\n88 18 7\n18 25 70\n\nlight-to-temperature map:\n45 77 23\n81 45 19\n68 64 13\n\ntemperature-to-humidity map:\n0 69 1\n1 0 69\n\nhumidity-to-location map:\n60 56 37\n56 93 4\nThe almanac starts by listing which seeds need to be planted: seeds 79, 14, 55, and 13.\nThe rest of the almanac contains a list of maps which describe how to convert numbers from a source category into numbers in a destination category. That is, the section that starts with seed-to-soil map: describes how to convert a seed number (the source) to a soil number (the destination). This lets the gardener and his team know which soil to use with which seeds, which water to use with which fertilizer, and so on.\nRather than list every source number and its corresponding destination number one by one, the maps describe entire ranges of numbers that can be converted. Each line within a map contains three numbers: the destination range start, the source range start, and the range length.\nConsider again the example seed-to-soil map:\n50 98 2\n52 50 48\nThe first line has a destination range start of 50, a source range start of 98, and a range length of 2. This line means that the source range starts at 98 and contains two values: 98 and 99. The destination range is the same length, but it starts at 50, so its two values are 50 and 51. With this information, you know that seed number 98 corresponds to soil number 50 and that seed number 99 corresponds to soil number 51.\nThe second line means that the source range starts at 50 and contains 48 values: 50, 51, …, 96, 97. This corresponds to a destination range starting at 52 and also containing 48 values: 52, 53, …, 98, 99. So, seed number 53 corresponds to soil number 55.\nAny source numbers that aren’t mapped correspond to the same destination number. So, seed number 10 corresponds to soil number 10.\nSo, the entire list of seed numbers and their corresponding soil numbers looks like this:\nseed  soil\n0     0\n1     1\n...   ...\n48    48\n49    49\n50    52\n51    53\n...   ...\n96    98\n97    99\n98    50\n99    51\nWith this map, you can look up the soil number required for each initial seed number:\nSeed number 79 corresponds to soil number 81.\nSeed number 14 corresponds to soil number 14.\nSeed number 55 corresponds to soil number 57.\nSeed number 13 corresponds to soil number 13.\nThe gardener and his team want to get started as soon as possible, so they’d like to know the closest location that needs a seed. Using these maps, find the lowest location number that corresponds to any of the initial seeds. To do this, you’ll need to convert each seed number through other categories until you can find its corresponding location number. In this example, the corresponding types are:\nSeed 79, soil 81, fertilizer 81, water 81, light 74, temperature 78, humidity 78, location 82.\nSeed 14, soil 14, fertilizer 53, water 49, light 42, temperature 42, humidity 43, location 43.\nSeed 55, soil 57, fertilizer 57, water 53, light 46, temperature 82, humidity 82, location 86.\nSeed 13, soil 13, fertilizer 52, water 41, light 34, temperature 34, humidity 35, location 35.\nSo, the lowest location number in this example is 35.\n\nsamp = '''\nseeds: 79 14 55 13\n\nseed-to-soil map:\n50 98 2\n52 50 48\n\nsoil-to-fertilizer map:\n0 15 37\n37 52 2\n39 0 15\n\nfertilizer-to-water map:\n49 53 8\n0 11 42\n42 0 7\n57 7 4\n\nwater-to-light map:\n88 18 7\n18 25 70\n\nlight-to-temperature map:\n45 77 23\n81 45 19\n68 64 13\n\ntemperature-to-humidity map:\n0 69 1\n1 0 69\n\nhumidity-to-location map:\n60 56 37\n56 93 4\n'''\n\n\nfrom fastcore.utils import L\n\n\ndef process_input(samp):\n    seeds,*lines = samp.split('\\n\\n')\n    seeds = L(seeds.strip().split(':')[1].split()).map(int)\n    return seeds, lines\nseeds, lines = process_input(samp)\nseeds, lines\n\n((#4) [79,14,55,13],\n ['seed-to-soil map:\\n50 98 2\\n52 50 48',\n  'soil-to-fertilizer map:\\n0 15 37\\n37 52 2\\n39 0 15',\n  'fertilizer-to-water map:\\n49 53 8\\n0 11 42\\n42 0 7\\n57 7 4',\n  'water-to-light map:\\n88 18 7\\n18 25 70',\n  'light-to-temperature map:\\n45 77 23\\n81 45 19\\n68 64 13',\n  'temperature-to-humidity map:\\n0 69 1\\n1 0 69',\n  'humidity-to-location map:\\n60 56 37\\n56 93 4\\n'])\n\n\n\ndef process(line): return L(line.split(':')[1].strip().split('\\n')).map(lambda x: L(x.split()).map(int))\n_lines = L(lines).map(process)\n_lines\n\n(#7) [[[50, 98, 2], [52, 50, 48]],[[0, 15, 37], [37, 52, 2], [39, 0, 15]],[[49, 53, 8], [0, 11, 42], [42, 0, 7], [57, 7, 4]],[[88, 18, 7], [18, 25, 70]],[[45, 77, 23], [81, 45, 19], [68, 64, 13]],[[0, 69, 1], [1, 0, 69]],[[60, 56, 37], [56, 93, 4]]]\n\n\n\nfrom dataclasses import dataclass\n@dataclass\nclass ref: dest:int;src:int;length:int\nref(1,2,3)\n\nref(dest=1, src=2, length=3)\n\n\n\na = ref(1,2,3)\na.src_end=10\na\n\nref(dest=1, src=2, length=3)\n\n\n\nobject_lines = _lines.map(lambda x: L(x).map(lambda o: ref(*o)))\nobject_lines\n\n(#7) [[ref(dest=50, src=98, length=2), ref(dest=52, src=50, length=48)],[ref(dest=0, src=15, length=37), ref(dest=37, src=52, length=2), ref(dest=39, src=0, length=15)],[ref(dest=49, src=53, length=8), ref(dest=0, src=11, length=42), ref(dest=42, src=0, length=7), ref(dest=57, src=7, length=4)],[ref(dest=88, src=18, length=7), ref(dest=18, src=25, length=70)],[ref(dest=45, src=77, length=23), ref(dest=81, src=45, length=19), ref(dest=68, src=64, length=13)],[ref(dest=0, src=69, length=1), ref(dest=1, src=0, length=69)],[ref(dest=60, src=56, length=37), ref(dest=56, src=93, length=4)]]\n\n\n\nline = object_lines[0]\nline\n\n(#2) [ref(dest=50, src=98, length=2),ref(dest=52, src=50, length=48)]\n\n\n\n@dataclass\nclass seed: src:int;length:int\nseed(90,10)\n\nseed(src=90, length=10)",
    "crumbs": [
      "2023",
      "Test case: range 90-99 (length 10) with rule 98->50 (length 2)"
    ]
  },
  {
    "objectID": "2023/day5_3.html#aoc-day-5",
    "href": "2023/day5_3.html#aoc-day-5",
    "title": "Test case: range 90-99 (length 10) with rule 98->50 (length 2)",
    "section": "",
    "text": "The almanac (your puzzle input) lists all of the seeds that need to be planted. It also lists what type of soil to use with each kind of seed, what type of fertilizer to use with each kind of soil, what type of water to use with each kind of fertilizer, and so on. Every type of seed, soil, fertilizer and so on is identified with a number, but numbers are reused by each category - that is, soil 123 and fertilizer 123 aren’t necessarily related to each other.\nFor example:\nseeds: 79 14 55 13\n\nseed-to-soil map:\n50 98 2\n52 50 48\n\nsoil-to-fertilizer map:\n0 15 37\n37 52 2\n39 0 15\n\nfertilizer-to-water map:\n49 53 8\n0 11 42\n42 0 7\n57 7 4\n\nwater-to-light map:\n88 18 7\n18 25 70\n\nlight-to-temperature map:\n45 77 23\n81 45 19\n68 64 13\n\ntemperature-to-humidity map:\n0 69 1\n1 0 69\n\nhumidity-to-location map:\n60 56 37\n56 93 4\nThe almanac starts by listing which seeds need to be planted: seeds 79, 14, 55, and 13.\nThe rest of the almanac contains a list of maps which describe how to convert numbers from a source category into numbers in a destination category. That is, the section that starts with seed-to-soil map: describes how to convert a seed number (the source) to a soil number (the destination). This lets the gardener and his team know which soil to use with which seeds, which water to use with which fertilizer, and so on.\nRather than list every source number and its corresponding destination number one by one, the maps describe entire ranges of numbers that can be converted. Each line within a map contains three numbers: the destination range start, the source range start, and the range length.\nConsider again the example seed-to-soil map:\n50 98 2\n52 50 48\nThe first line has a destination range start of 50, a source range start of 98, and a range length of 2. This line means that the source range starts at 98 and contains two values: 98 and 99. The destination range is the same length, but it starts at 50, so its two values are 50 and 51. With this information, you know that seed number 98 corresponds to soil number 50 and that seed number 99 corresponds to soil number 51.\nThe second line means that the source range starts at 50 and contains 48 values: 50, 51, …, 96, 97. This corresponds to a destination range starting at 52 and also containing 48 values: 52, 53, …, 98, 99. So, seed number 53 corresponds to soil number 55.\nAny source numbers that aren’t mapped correspond to the same destination number. So, seed number 10 corresponds to soil number 10.\nSo, the entire list of seed numbers and their corresponding soil numbers looks like this:\nseed  soil\n0     0\n1     1\n...   ...\n48    48\n49    49\n50    52\n51    53\n...   ...\n96    98\n97    99\n98    50\n99    51\nWith this map, you can look up the soil number required for each initial seed number:\nSeed number 79 corresponds to soil number 81.\nSeed number 14 corresponds to soil number 14.\nSeed number 55 corresponds to soil number 57.\nSeed number 13 corresponds to soil number 13.\nThe gardener and his team want to get started as soon as possible, so they’d like to know the closest location that needs a seed. Using these maps, find the lowest location number that corresponds to any of the initial seeds. To do this, you’ll need to convert each seed number through other categories until you can find its corresponding location number. In this example, the corresponding types are:\nSeed 79, soil 81, fertilizer 81, water 81, light 74, temperature 78, humidity 78, location 82.\nSeed 14, soil 14, fertilizer 53, water 49, light 42, temperature 42, humidity 43, location 43.\nSeed 55, soil 57, fertilizer 57, water 53, light 46, temperature 82, humidity 82, location 86.\nSeed 13, soil 13, fertilizer 52, water 41, light 34, temperature 34, humidity 35, location 35.\nSo, the lowest location number in this example is 35.\n\nsamp = '''\nseeds: 79 14 55 13\n\nseed-to-soil map:\n50 98 2\n52 50 48\n\nsoil-to-fertilizer map:\n0 15 37\n37 52 2\n39 0 15\n\nfertilizer-to-water map:\n49 53 8\n0 11 42\n42 0 7\n57 7 4\n\nwater-to-light map:\n88 18 7\n18 25 70\n\nlight-to-temperature map:\n45 77 23\n81 45 19\n68 64 13\n\ntemperature-to-humidity map:\n0 69 1\n1 0 69\n\nhumidity-to-location map:\n60 56 37\n56 93 4\n'''\n\n\nfrom fastcore.utils import L\n\n\ndef process_input(samp):\n    seeds,*lines = samp.split('\\n\\n')\n    seeds = L(seeds.strip().split(':')[1].split()).map(int)\n    return seeds, lines\nseeds, lines = process_input(samp)\nseeds, lines\n\n((#4) [79,14,55,13],\n ['seed-to-soil map:\\n50 98 2\\n52 50 48',\n  'soil-to-fertilizer map:\\n0 15 37\\n37 52 2\\n39 0 15',\n  'fertilizer-to-water map:\\n49 53 8\\n0 11 42\\n42 0 7\\n57 7 4',\n  'water-to-light map:\\n88 18 7\\n18 25 70',\n  'light-to-temperature map:\\n45 77 23\\n81 45 19\\n68 64 13',\n  'temperature-to-humidity map:\\n0 69 1\\n1 0 69',\n  'humidity-to-location map:\\n60 56 37\\n56 93 4\\n'])\n\n\n\ndef process(line): return L(line.split(':')[1].strip().split('\\n')).map(lambda x: L(x.split()).map(int))\n_lines = L(lines).map(process)\n_lines\n\n(#7) [[[50, 98, 2], [52, 50, 48]],[[0, 15, 37], [37, 52, 2], [39, 0, 15]],[[49, 53, 8], [0, 11, 42], [42, 0, 7], [57, 7, 4]],[[88, 18, 7], [18, 25, 70]],[[45, 77, 23], [81, 45, 19], [68, 64, 13]],[[0, 69, 1], [1, 0, 69]],[[60, 56, 37], [56, 93, 4]]]\n\n\n\nfrom dataclasses import dataclass\n@dataclass\nclass ref: dest:int;src:int;length:int\nref(1,2,3)\n\nref(dest=1, src=2, length=3)\n\n\n\na = ref(1,2,3)\na.src_end=10\na\n\nref(dest=1, src=2, length=3)\n\n\n\nobject_lines = _lines.map(lambda x: L(x).map(lambda o: ref(*o)))\nobject_lines\n\n(#7) [[ref(dest=50, src=98, length=2), ref(dest=52, src=50, length=48)],[ref(dest=0, src=15, length=37), ref(dest=37, src=52, length=2), ref(dest=39, src=0, length=15)],[ref(dest=49, src=53, length=8), ref(dest=0, src=11, length=42), ref(dest=42, src=0, length=7), ref(dest=57, src=7, length=4)],[ref(dest=88, src=18, length=7), ref(dest=18, src=25, length=70)],[ref(dest=45, src=77, length=23), ref(dest=81, src=45, length=19), ref(dest=68, src=64, length=13)],[ref(dest=0, src=69, length=1), ref(dest=1, src=0, length=69)],[ref(dest=60, src=56, length=37), ref(dest=56, src=93, length=4)]]\n\n\n\nline = object_lines[0]\nline\n\n(#2) [ref(dest=50, src=98, length=2),ref(dest=52, src=50, length=48)]\n\n\n\n@dataclass\nclass seed: src:int;length:int\nseed(90,10)\n\nseed(src=90, length=10)",
    "crumbs": [
      "2023",
      "Test case: range 90-99 (length 10) with rule 98->50 (length 2)"
    ]
  },
  {
    "objectID": "2023/day5_3.html#part2",
    "href": "2023/day5_3.html#part2",
    "title": "Test case: range 90-99 (length 10) with rule 98->50 (length 2)",
    "section": "Part2",
    "text": "Part2\nEveryone will starve if you only plant such a small number of seeds. Re-reading the almanac, it looks like the seeds: line actually describes ranges of seed numbers.\nThe values on the initial seeds: line come in pairs. Within each pair, the first value is the start of the range and the second value is the length of the range. So, in the first line of the example above:\nseeds: 79 14 55 13 This line describes two ranges of seed numbers to be planted in the garden. The first range starts with seed number 79 and contains 14 values: 79, 80, …, 91, 92. The second range starts with seed number 55 and contains 13 values: 55, 56, …, 66, 67.\nNow, rather than considering four seed numbers, you need to consider a total of 27 seed numbers.\nIn the above example, the lowest location number can be obtained from seed number 82, which corresponds to soil 84, fertilizer 84, water 84, light 77, temperature 45, humidity 46, and location 46. So, the lowest location number is 46.\nAI Prompt\nif you look at part two, it seems not to process single seed at a time, but to process something like ‘a’, how to convert ‘a’ based on ‘line’\nAI Response\nLet’s think about how to convert a range of seeds (represented by your a object which has a start position src and a length) using a mapping line.\nLooking at your example: - a represents a range starting at 90 with length 10 (so it covers 90-99) - line has two mapping rules: 1. 98-&gt;50 for length 2 (98,99 map to 50,51) 2. 50-&gt;52 for length 48 (50-97 map to 52-99)\nWould you like me to help you think through how these ranges might overlap and what output ranges we should get? Let’s break this down step by step.\nWould you like to start by considering what happens when an input range overlaps with a mapping rule?\nAI Prompt\nhelp me think\nAI Response\nOkay, let’s visualize this specific example:\nYour input range (a): 90 to 99 (length 10)\nThe mapping rules in line: 1. Rule 1: 98,99 → 50,51 2. Rule 2: 50-97 → 52-99\nLooking at your input range (90-99), it gets split into two parts: 1. 90-97 (falls under Rule 2) 2. 98-99 (falls under Rule 1)\nShall we work out what happens to each part? Which part would you like to look at first?\nAI Prompt\nhow to code\nAI Response\nLet’s break this down into steps. First, we need a function that can handle one input range and one mapping rule. Here’s what we need to check:\n\nDoes the input range overlap with the mapping rule at all?\nIf it does overlap, what are the overlapping and non-overlapping parts?\n\nWould you like me to help you write this function step by step? We can start with just checking if two ranges overlap.\nOr would you prefer to try writing some code yourself first? Let me know which approach you’d prefer!\nAI Prompt\nwrite this function\nAI Response\nI’ll help you write a function to check if two ranges overlap. Let’s start with this basic function:\ndef ranges_overlap(range1_start, range1_length, range2_start, range2_length):\n    range1_end = range1_start + range1_length - 1\n    range2_end = range2_start + range2_length - 1\n    \n    return not (range1_end &lt; range2_start or range1_start &gt; range2_end)\nWould you like to test this function with some example cases before we move on to handling the overlapping parts?\n\nl = line[0]\nl\n\nnamespace(dest=50, src=98, length=2)\n\n\n\ndef is_overlap(a,l): return a.src&lt;(l.src+l.length) and l.src&lt;(a.src+a.length)\nis_overlap(a,l)\n\nTrue\n\n\n\nis_overlap(get_seed_object(10,5),get_seed_object(6,5))\n\nTrue\n\n\nAI Prompt\nhow to get new object based on a and many l that with a starting point, and a length as class object, it can return multiple cutted class object\nAI Response\nLet’s write a function that takes an input range object (a) and a list of mapping rules (l), and returns a list of new range objects for the mapped parts. Here’s a suggested approach:\ndef map_range(a, rules):\n    result = []\n    # Each object in result will have a src and length, just like input\n    # We'll need to:\n    # 1. Find overlapping parts\n    # 2. Calculate new starting points based on the mapping rules\n    # 3. Handle parts that don't overlap with any rules (they map to themselves)\n    \n    return result\nWould you like to work through this step by step? We can start by handling a single overlap between the input range and one rule, then build up to handling multiple rules. Which part would you like to tackle first?\nAI Prompt\nyes, make the function\nAI Response\nLet’s build the function step by step. First, let’s handle a single input range and a single rule:\ndef map_single_range(a, rule):\n    # No overlap case\n    if not is_overlap(a, rule): \n        return [a]\n    \n    # Calculate overlapping region\n    start = max(a.src, rule.src)\n    end = min(a.src + a.length, rule.src + rule.length)\n    \n    # Calculate new destination for overlapping part\n    offset = rule.dest - rule.src\n    mapped = get_seed_object(start + offset, end - start)\n    \n    result = []\n    # Add part before overlap if it exists\n    if a.src &lt; rule.src:\n        result.append(get_seed_object(a.src, rule.src - a.src))\n    \n    # Add mapped part\n    result.append(mapped)\n    \n    # Add part after overlap if it exists\n    if a.src + a.length &gt; rule.src + rule.length:\n        after_start = rule.src + rule.length\n        result.append(get_seed_object(after_start, (a.src + a.length) - after_start))\n    \n    return result\nWould you like to test this with a simple example before we build the function that handles multiple rules?\nAI Prompt\nyes\n\ndef map_single_range(a, rule):\n    # No overlap case\n    if not is_overlap(a, rule): \n        return [a]\n    \n    # Calculate overlapping region\n    start = max(a.src, rule.src)\n    end = min(a.src + a.length, rule.src + rule.length)\n    \n    # Calculate new destination for overlapping part\n    offset = rule.dest - rule.src\n    mapped = get_seed_object(start + offset, end - start)\n    \n    result = []\n    # Add part before overlap if it exists\n    if a.src &lt; rule.src:\n        result.append(get_seed_object(a.src, rule.src - a.src))\n    \n    # Add mapped part\n    result.append(mapped)\n    \n    # Add part after overlap if it exists\n    if a.src + a.length &gt; rule.src + rule.length:\n        after_start = rule.src + rule.length\n        result.append(get_seed_object(after_start, (a.src + a.length) - after_start))\n    \n    return result\n\n# Test case: range 90-99 (length 10) with rule 98-&gt;50 (length 2)\ntest_range = get_seed_object(90, 10)\ntest_rule = line[0]  # This was the rule mapping 98,99 to 50,51\n\nresult = map_single_range(test_range, test_rule)\nfor r in result:\n    print(f\"Range starting at {r.src} with length {r.length}\")\n\nRange starting at 90 with length 8\nRange starting at 50 with length 2\n\n\nAI Prompt\nhow about handle multiple rules\nAI Response\nLet’s write a function that handles multiple rules. We’ll need to apply each rule in order and keep track of all the resulting ranges. Here’s a suggested approach:\ndef map_range(a, rules):\n    ranges_to_map = [a]\n    mapped_ranges = []\n    \n    for rule in rules:\n        new_ranges = []\n        for r in ranges_to_map:\n            new_ranges.extend(map_single_range(r, rule))\n        ranges_to_map = new_ranges\n    \n    return ranges_to_map\nWould you like to test this with both rules from your example? We could try it with:\ntest_range = get_seed_object(90, 10)  # 90-99\nresult = map_range(test_range, line)\nShall we try this and examine the results?\n\ndef map_range(a, rules):\n    ranges_to_map = [a]\n    mapped_ranges = []\n    \n    for rule in rules:\n        new_ranges = []\n        for r in ranges_to_map:\n            new_ranges.extend(map_single_range(r, rule))\n        ranges_to_map = new_ranges\n    \n    return ranges_to_map\n\ntest_range = get_seed_object(90, 10)  # 90-99\nresult = map_range(test_range, line)\n\n\nresult\n\n[namespace(src=92, length=8), namespace(src=52, length=2)]\n\n\n\nline\n\n(#2) [namespace(dest=50, src=98, length=2),namespace(dest=52, src=50, length=48)]\n\n\nAI Prompt\nis the result incorporate the two rules in line?\nAI Response\nLet’s analyze what’s happening:\nYour input range is 90-99 (length 10)\nThe two rules are: 1. 98-&gt;50 length 2 (98,99 → 50,51) 2. 50-&gt;52 length 48 (50-97 → 52-99)\nLooking at the result:\n[namespace(src=92, length=8), namespace(src=52, length=2)]\nThis doesn’t seem quite right. The first rule should split 90-99 into: - 90-97 (length 8) - 98-99 → 50-51 (length 2)\nThen the second rule should map 90-97 to 92-99 (since 50→52).\nLet’s debug the function. Would you like to add some print statements to see how the ranges are being transformed at each step?\nAI Prompt\nmodify the code to make it correct\nAI Response\nLet’s modify the code with more detailed debug information first:\ndef map_single_range(a, rule):\n    # No overlap case\n    if not is_overlap(a, rule): \n        return [a]\n    \n    # Calculate overlapping region\n    start = max(a.src, rule.src)\n    end = min(a.src + a.length, rule.src + rule.length)\n    \n    # Calculate new destination for overlapping part\n    offset = rule.dest - rule.src\n    mapped = get_seed_object(start + offset, end - start)\n    \n    result = []\n    # Add part before overlap if it exists\n    if a.src &lt; rule.src:\n        result.append(get_seed_object(a.src, rule.src - a.src))\n    \n    # Add mapped part\n    result.append(mapped)\n    \n    # Add part after overlap if it exists\n    if a.src + a.length &gt; rule.src + rule.length:\n        after_start = rule.src + rule.length\n        result.append(get_seed_object(after_start, (a.src + a.length) - after_start))\n    \n    print(f\"Input range: {a.src}-{a.src+a.length-1}\")\n    print(f\"Rule: {rule.src}-{rule.src+rule.length-1} → {rule.dest}-{rule.dest+rule.length-1}\")\n    print(f\"Result ranges: {[(r.src, r.length) for r in result]}\\n\")\n    return result\n\ndef map_range(a, rules):\n    ranges_to_map = [a]\n    \n    for i, rule in enumerate(rules):\n        print(f\"\\nApplying rule {i+1}:\")\n        new_ranges = []\n        for r in ranges_to_map:\n            new_ranges.extend(map_single_range(r, rule))\n        ranges_to_map = new_ranges\n    \n    return ranges_to_map\n\ntest_range = get_seed_object(90, 10)  # 90-99\nresult = map_range(test_range, line)\nLet’s run this and see exactly what’s happening at each step. Then we can fix any issues we find. Would you like to try this debug version?\n\ndef map_single_range(a, rule):\n    # No overlap case\n    if not is_overlap(a, rule): \n        return [a]\n    \n    # Calculate overlapping region\n    start = max(a.src, rule.src)\n    end = min(a.src + a.length, rule.src + rule.length)\n    \n    # Calculate new destination for overlapping part\n    offset = rule.dest - rule.src\n    mapped = get_seed_object(start + offset, end - start)\n    \n    result = []\n    # Add part before overlap if it exists\n    if a.src &lt; rule.src:\n        result.append(get_seed_object(a.src, rule.src - a.src))\n    \n    # Add mapped part\n    result.append(mapped)\n    \n    # Add part after overlap if it exists\n    if a.src + a.length &gt; rule.src + rule.length:\n        after_start = rule.src + rule.length\n        result.append(get_seed_object(after_start, (a.src + a.length) - after_start))\n    \n    print(f\"Input range: {a.src}-{a.src+a.length-1}\")\n    print(f\"Rule: {rule.src}-{rule.src+rule.length-1} → {rule.dest}-{rule.dest+rule.length-1}\")\n    print(f\"Result ranges: {[(r.src, r.length) for r in result]}\\n\")\n    return result\n\ndef map_range(a, rules):\n    ranges_to_map = [a]\n    \n    for i, rule in enumerate(rules):\n        print(f\"\\nApplying rule {i+1}:\")\n        new_ranges = []\n        for r in ranges_to_map:\n            new_ranges.extend(map_single_range(r, rule))\n        ranges_to_map = new_ranges\n    \n    return ranges_to_map\n\ntest_range = get_seed_object(90, 10)  # 90-99\nresult = map_range(test_range, line)\nresult\n\n\nApplying rule 1:\nInput range: 90-99\nRule: 98-99 → 50-51\nResult ranges: [(90, 8), (50, 2)]\n\n\nApplying rule 2:\nInput range: 90-97\nRule: 50-97 → 52-99\nResult ranges: [(92, 8)]\n\nInput range: 50-51\nRule: 50-97 → 52-99\nResult ranges: [(52, 2)]\n\n\n\n[namespace(src=92, length=8), namespace(src=52, length=2)]\n\n\nAI Prompt\ndo you think is this time correct?\nAI Response\nLet’s analyze the steps:\n\nFirst rule (98→50, length 2):\n\nSplit 90-99 into:\n\n90-97 (length 8) - unmapped\n98-99 → 50-51 (length 2) - mapped\n\n\nSecond rule (50→52, length 48):\n\n90-97 → 92-99 (mapped by adding offset of 2)\n50-51 → 52-53 (mapped correctly)\n\n\nYes, this looks correct now! Because: 1. The part that was 98-99 got mapped to 50-51 by the first rule, then to 52-53 by the second rule 2. The part that was 90-97 got mapped to 92-99 by the second rule\nThe final ranges [92-99, 52-53] represent all the correct mappings. Would you like to verify this with a different test case?",
    "crumbs": [
      "2023",
      "Test case: range 90-99 (length 10) with rule 98->50 (length 2)"
    ]
  },
  {
    "objectID": "2023/Day_2.html",
    "href": "2023/Day_2.html",
    "title": "Day 2",
    "section": "",
    "text": "You play several games and record the information from each game (your puzzle input). Each game is listed with its ID number (like the 11 in Game 11: …) followed by a semicolon-separated list of subsets of cubes that were revealed from the bag (like 3 red, 5 green, 4 blue).\nFor example, the record of a few games might look like this:\nIn game 1, three sets of cubes are revealed from the bag (and then put back again). The first set is 3 blue cubes and 4 red cubes; the second set is 1 red cube, 2 green cubes, and 6 blue cubes; the third set is only 2 green cubes.\nThe Elf would first like to know which games would have been possible if the bag contained only 12 red cubes, 13 green cubes, and 14 blue cubes?\nIn the example above, games 1, 2, and 5 would have been possible if the bag had been loaded with that configuration. However, game 3 would have been impossible because at one point the Elf showed you 20 red cubes at once; similarly, game 4 would also have been impossible because the Elf showed you 15 blue cubes at once. If you add up the IDs of the games that would have been possible, you get 8.\nDetermine which games would have been possible if the bag had been loaded with only 12 red cubes, 13 green cubes, and 14 blue cubes. What is the sum of the IDs of those games?\nsample = '''\nGame 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green\nGame 2: 1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue\nGame 3: 8 green, 6 blue, 20 red; 5 blue, 4 red, 13 green; 5 green, 1 red\nGame 4: 1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, 15 blue, 14 red\nGame 5: 6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green\n'''\nsample.split(':')\n\n['\\nGame 1',\n ' 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green\\nGame 2',\n ' 1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue\\nGame 3',\n ' 8 green, 6 blue, 20 red; 5 blue, 4 red, 13 green; 5 green, 1 red\\nGame 4',\n ' 1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, 15 blue, 14 red\\nGame 5',\n ' 6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green\\n']\nAI Prompt\nHow to get the sample input in the correct format?\nAI Response\nLet’s break this down into steps. First, we need to process this input string into a more usable format. Looking at your split attempt, we can see we need to:\nWould you like to try writing some code to handle the first step? We could start by splitting the input into lines and removing any empty lines.\nWould you like me to suggest how to do this, or would you prefer to try it yourself first?\nsample.splitlines()\n\n['',\n 'Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green',\n 'Game 2: 1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue',\n 'Game 3: 8 green, 6 blue, 20 red; 5 blue, 4 red, 13 green; 5 green, 1 red',\n 'Game 4: 1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, 15 blue, 14 red',\n 'Game 5: 6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green']\nxs = [o for o in sample.splitlines() if o]\nxs\n\n['Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green',\n 'Game 2: 1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue',\n 'Game 3: 8 green, 6 blue, 20 red; 5 blue, 4 red, 13 green; 5 green, 1 red',\n 'Game 4: 1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, 15 blue, 14 red',\n 'Game 5: 6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green']\n[o.split(':') for o in xs]\n\n[['Game 1', ' 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green'],\n ['Game 2', ' 1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue'],\n ['Game 3',\n  ' 8 green, 6 blue, 20 red; 5 blue, 4 red, 13 green; 5 green, 1 red'],\n ['Game 4',\n  ' 1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, 15 blue, 14 red'],\n ['Game 5', ' 6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green']]\n[o.split(':')[1] for o in xs]\n\n[' 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green',\n ' 1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue',\n ' 8 green, 6 blue, 20 red; 5 blue, 4 red, 13 green; 5 green, 1 red',\n ' 1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, 15 blue, 14 red',\n ' 6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green']\n[o.split(': ')[1] for o in xs]\n\n['3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green',\n '1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue',\n '8 green, 6 blue, 20 red; 5 blue, 4 red, 13 green; 5 green, 1 red',\n '1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, 15 blue, 14 red',\n '6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green']\nxs = [o.split(': ')[1] for o in xs]\nxs\n\n['3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green',\n '1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue',\n '8 green, 6 blue, 20 red; 5 blue, 4 red, 13 green; 5 green, 1 red',\n '1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, 15 blue, 14 red',\n '6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green']\nAI Prompt\nnow where are we?\nAI Response\nLooking at where we are now, we have a list xs where each item represents one game’s cube sets, with the “Game X:” part removed. For example, the first game is now: '3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green'\nThe next step would be to: 1. Split each game into its individual sets (separated by semicolons) 2. Parse each set to count the number of cubes of each color\nWould you like to try handling the semicolon split first? We can use the .split(';') method on each game string.\nWould you like to try that, or would you like some guidance?\nfor games in xs:\n    print(games.split(';'))\n\n['3 blue, 4 red', ' 1 red, 2 green, 6 blue', ' 2 green']\n['1 blue, 2 green', ' 3 green, 4 blue, 1 red', ' 1 green, 1 blue']\n['8 green, 6 blue, 20 red', ' 5 blue, 4 red, 13 green', ' 5 green, 1 red']\n['1 green, 3 red, 6 blue', ' 3 green, 6 red', ' 3 green, 15 blue, 14 red']\n['6 red, 1 blue, 3 green', ' 2 blue, 1 red, 2 green']\nAI Prompt\nthen what’s next\nAI Response\nNow we need to parse each set to count the cubes of each color. Looking at a single set like ‘3 blue, 4 red’, we need to: 1. Split by comma 2. Extract the number and color from each part\nLet’s try with one set first to make sure we understand it. Would you like to try splitting one of these by comma and see what we get? We could use something like:\nWould you like to try that?\nxs[0].split(';')[0]\n\n'3 blue, 4 red'\nx = xs[0].split(';')[0]\nx.split(',')\n\n['3 blue', ' 4 red']\nAI Prompt\nthen what’s next\nAI Response\nNow we have items like ‘3 blue’ and ’ 4 red’. We need to: 1. Split each of these into the number and color 2. Remove any extra spaces\nLet’s try with one of these strings. Would you like to try splitting ‘3 blue’ into its number and color components? You can use the .strip() method to remove extra spaces first.\nWould you like to try that?\nx1 = x.split(', ')\nx1\n\n['3 blue', '4 red']\nAI Prompt\nwhat’s next\nAI Response\nNow we can split each item like ‘3 blue’ into its number and color. We can use .split() again since they’re separated by a space. Let’s try with the first item:\nWould you like to try splitting x1[0] into its number and color parts? Then we can convert the number part to an integer using int().\nWould you like to try that?\nx1[0].split(' ')\n\n['3', 'blue']\nAI Prompt\nwhat’s next\nAI Response\nPerfect! Now we can create a small dictionary to store the count for each color. For each game, we’ll need to: 1. Track the maximum number seen for each color 2. Compare those maximums against our limits (12 red, 13 green, 14 blue)\nWould you like to try creating a dictionary for the first set of cubes? We could use something like this structure:\nWould you like to try that?\nsingle = x1[0].split(' ')\nsingle\n\n['3', 'blue']\ndict(key=single[1],value=single[0])\n\n{'key': 'blue', 'value': '3'}\ndict(single[1]=single[0])\n\n  Cell In[1], line 1\n    dict(single[1]=single[0])\n         ^\nSyntaxError: expression cannot contain assignment, perhaps you meant \"==\"?\nAI Prompt\nhow to make it to be dictionary?\nAI Response\nTo create a dictionary from our color and number, we have a few options. Here’s one way:\nThis will create a dictionary with the color as the key and the number (converted to integer) as the value.\nWould you like to try that? Then we can look at how to combine multiple colors into one dictionary.\n{single[1]:single[0]}\n\n{'blue': '3'}\nAI Prompt\nwhat’s next\nAI Response\nNow we need to handle both parts of x1 (both the blue and red cubes) in a single dictionary. We can: 1. Create an empty dictionary 2. Add each color-number pair to it\nWould you like to try creating an empty dictionary and adding both colors from x1? Here’s how we could start:\nWould you like to try adding the colors and their counts to this dictionary?\nx1\n\n['3 blue', '4 red']\ncubes={}\nfor o in x1:\n    single = o.split(' ')\n    single_dict = {single[1]:single[0]}\nsingle_dict\n\n{'red': '4'}\nAI Prompt\nhow to add to the empty dict?\nAI Response\nTo add items to a dictionary, we use the update() method or direct assignment. Here’s how we can modify your code:\nOr using update():\nWould you like to try one of these approaches? I also added int() to convert the numbers from strings to integers.\ncubes={}\nfor o in x1:\n    single = o.split(' ')\n    cubes[single[1]] = single[0]\ncubes\n\n{'blue': '3', 'red': '4'}\nAI Prompt\nwhat’s next?\nAI Response\nNow we need to do this for each set of cubes in a game, and keep track of the maximum number seen for each color. We should:\nWould you like to try modifying your code to use int() first? Then we can work on handling multiple sets.\ncubes={}\nfor o in x1:\n    single = o.split(' ')\n    cubes[single[1]] = int(single[0])\ncubes\n\n{'blue': 3, 'red': 4}\nAI Prompt\nwhat’s next?\nAI Response\nNow let’s work on handling all sets in a game. Remember that each game string in xs has multiple sets separated by semicolons. Let’s:\nWould you like to try getting all the sets from the first game using .split(';')? We can start with:\nWould you like to try that and see what sets we get?\ngame = xs[0]\ngame\n\n'3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green'\nfor g in game.split('; '):\n    print(g.split(', '))\n\n['3 blue', '4 red']\n['1 red', '2 green', '6 blue']\n['2 green']\ndef get_single_dict(single):\n    cubes={}\n    for o in single:\n        single = o.split(' ')\n        cubes[single[1]] = int(single[0])\n    return cubes\n\nget_single_dict(['3 blue', '4 red'])\n\n{'blue': 3, 'red': 4}\nfor g in game.split('; '):\n    single = g.split(', ')\n    print(get_single_dict(single))\n\n{'blue': 3, 'red': 4}\n{'red': 1, 'green': 2, 'blue': 6}\n{'green': 2}\nAI Prompt\nwhat’s next?\nAI Response\nNow we need to track the maximum number seen for each color across all sets in a game. We’ll need to:\nWould you like to try creating a dictionary to track the maximums? We can start with something like:\nThen we’ll need to update these values as we process each set. Would you like to try that?\nmax_cubes = {'red': 0, 'green': 0, 'blue': 0}\nAI Prompt\nhow to update max_cubes dictionary with value?\nAI Response\nTo update max_cubes with the maximum value for each color, we can use the max() function. For each set, we’ll want to:\nHere’s one way to do it:\nWould you like to try this with your code? We can then check if it’s updating the maximums correctly.\nmax_cubes = {'red': 0, 'green': 0, 'blue': 0}\nfor g in game.split('; '):\n    single = g.split(', ')\n    single_dict = get_single_dict(single)\n    for color in single_dict:\n        max_cubes[color] = max(max_cubes[color],single_dict[color])\nmax_cubes\n\n{'red': 4, 'green': 2, 'blue': 6}\nAI Prompt\nwhat’s next?\nAI Response\nNow we need to:\nWould you like to start by creating a function that processes a single game and returns whether it’s possible? We can use our existing code as a starting point.\nWould you like to try that?\nrequire_cubes = {'red':12,'green':13, 'blue':14}\nAI Prompt\nhow to compare the values between max_cubes and require_cubes?\nAI Response\nTo compare values between max_cubes and require_cubes, we need to check if each color in max_cubes is less than or equal to the required amount. Here’s one way:\nOr we could use the all() function:\nWould you like to try one of these approaches to check if a game is possible?\ndef compare_require(max_cubes,require_cubes):\n    for color in max_cubes:\n        if max_cubes[color] &gt; require_cubes[color]:\n            return False\n    return True\ncompare_require(max_cubes,require_cubes)\n\nTrue\ndef get_max_cubes(game):\n    max_cubes = {'red': 0, 'green': 0, 'blue': 0}\n    for g in game.split('; '):\n        single = g.split(', ')\n        single_dict = get_single_dict(single)\n        for color in single_dict:\n            max_cubes[color] = max(max_cubes[color],single_dict[color])\n    return max_cubes\ngame\n\n'3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green'\nget_max_cubes(game)\n\n{'red': 4, 'green': 2, 'blue': 6}\nxs\n\n['3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green',\n '1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue',\n '8 green, 6 blue, 20 red; 5 blue, 4 red, 13 green; 5 green, 1 red',\n '1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, 15 blue, 14 red',\n '6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green']\nget_max_cubes(xs[2])\n\n{'red': 20, 'green': 13, 'blue': 6}\nfor game in xs:\n    max_cubes = get_max_cubes(game)\n    print(max_cubes)\n    return compare_require(max_cubes,require_cubes)\n\n  Cell In[1], line 4\n    return compare_require(max_cubes,require_cubes)\n    ^\nSyntaxError: 'return' outside function\nfor game in xs:\n    max_cubes = get_max_cubes(game)\n    print(max_cubes)\n    print(compare_require(max_cubes,require_cubes))\n\n{'red': 4, 'green': 2, 'blue': 6}\nTrue\n{'red': 1, 'green': 3, 'blue': 4}\nTrue\n{'red': 20, 'green': 13, 'blue': 6}\nFalse\n{'red': 14, 'green': 3, 'blue': 15}\nFalse\n{'red': 6, 'green': 3, 'blue': 2}\nTrue\nAI Prompt\nwhat’s next?\nAI Response\nNow we need to:\nWould you like to modify the loop to include the game ID and sum up the valid game IDs? We can use enumerate() to get both the index and the game value.\nWould you like to try that?\nfor index, game in enumerate(xs,start=1):print(index)\n\n1\n2\n3\n4\n5\nindex_sum = []\nfor index, game in enumerate(xs,start=1):\n    max_cubes = get_max_cubes(game)\n    if compare_require(max_cubes,require_cubes):\n        index_sum.append(index)\n\nindex_sum\n\n[1, 2, 5]\nindex_sum = 0\nfor index, game in enumerate(xs,start=1):\n    max_cubes = get_max_cubes(game)\n    if compare_require(max_cubes,require_cubes):\n        index_sum+=index\nindex_sum\n\n8\nfrom aocd import get_data\ninp = get_data(day=2,year=2023)\nxs = inp.splitlines()\nindex_sum = 0\nfor index, game in enumerate(xs,start=1):\n    max_cubes = get_max_cubes(game)\n    if compare_require(max_cubes,require_cubes):\n        index_sum+=index\nindex_sum\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[1], line 3\n      1 index_sum = 0\n      2 for index, game in enumerate(xs,start=1):\n----&gt; 3     max_cubes = get_max_cubes(game)\n      4     if compare_require(max_cubes,require_cubes):\n      5         index_sum+=index\n\nCell In[1], line 5, in get_max_cubes(game)\n      3 for g in game.split('; '):\n      4     single = g.split(', ')\n----&gt; 5     single_dict = get_single_dict(single)\n      6     for color in single_dict:\n      7         max_cubes[color] = max(max_cubes[color],single_dict[color])\n\nCell In[1], line 5, in get_single_dict(single)\n      3 for o in single:\n      4     single = o.split(' ')\n----&gt; 5     cubes[single[1]] = int(single[0])\n      6 return cubes\n\nValueError: invalid literal for int() with base 10: 'Game'\n\n\nValueError: invalid literal for int() with base 10: 'Game'\nTraceback (most recent call last):\n\n  File \"/usr/local/lib/python3.11/site-packages/IPython/core/interactiveshell.py\", line 3577, in run_code\n    exec(code_obj, self.user_global_ns, self.user_ns)\n\n  File \"&lt;ipython-input-1-322d148b1048&gt;\", line 3, in &lt;module&gt;\n    max_cubes = get_max_cubes(game)\n                ^^^^^^^^^^^^^^^^^^^\n\n  File \"&lt;ipython-input-1-e8eaea586eab&gt;\", line 5, in get_max_cubes\n    single_dict = get_single_dict(single)\n                  ^^^^^^^^^^^^^^^^^^^^^^^\n\n  File \"&lt;ipython-input-1-a7e31a22c225&gt;\", line 5, in get_single_dict\n    cubes[single[1]] = int(single[0])\n                       ^^^^^^^^^^^^^^\n\nValueError: invalid literal for int() with base 10: 'Game'\nxs[:10]\n\n['Game 1: 7 red, 14 blue; 2 blue, 3 red, 3 green; 4 green, 12 blue, 15 red; 3 green, 12 blue, 3 red; 11 red, 2 green',\n 'Game 2: 16 blue, 9 red, 5 green; 8 red; 8 blue, 5 green, 12 red; 11 blue, 8 green, 17 red',\n 'Game 3: 8 green, 1 blue, 7 red; 12 red, 6 blue, 9 green; 2 blue, 1 red, 14 green; 9 green, 4 red; 2 red, 1 blue, 8 green',\n 'Game 4: 1 blue, 3 green; 2 green, 1 blue, 1 red; 1 red, 3 green',\n 'Game 5: 6 red, 1 blue; 1 green; 5 red, 2 green; 1 red, 1 blue, 3 green',\n 'Game 6: 3 green, 4 red, 1 blue; 2 blue, 5 green, 2 red; 12 green, 3 blue, 2 red; 4 blue, 1 green, 4 red; 11 green, 6 red; 5 green, 10 red, 3 blue',\n 'Game 7: 2 blue, 3 green, 16 red; 1 blue, 3 red; 2 green, 13 red; 18 red, 2 blue, 1 green; 3 red, 1 blue',\n 'Game 8: 4 red, 3 blue, 8 green; 2 red, 16 green; 2 red, 1 blue',\n 'Game 9: 4 green, 14 blue, 8 red; 17 blue, 3 red, 5 green; 2 green, 4 red, 6 blue; 7 red, 2 green, 18 blue; 3 red, 19 blue, 4 green; 4 green, 8 red, 6 blue',\n 'Game 10: 12 green, 7 red, 1 blue; 6 red, 12 green; 6 red, 7 green, 1 blue; 1 red, 1 blue, 18 green; 11 green, 1 blue']\ndef process_raw(inp):\n    xs = [o for o in inp.splitlines() if o]\n    xs = [o.split(': ')[1] for o in xs]\n    return xs\nout = process_raw(inp)\nout[:3]\n\n['7 red, 14 blue; 2 blue, 3 red, 3 green; 4 green, 12 blue, 15 red; 3 green, 12 blue, 3 red; 11 red, 2 green',\n '16 blue, 9 red, 5 green; 8 red; 8 blue, 5 green, 12 red; 11 blue, 8 green, 17 red',\n '8 green, 1 blue, 7 red; 12 red, 6 blue, 9 green; 2 blue, 1 red, 14 green; 9 green, 4 red; 2 red, 1 blue, 8 green']\nindex_sum = 0\nfor index, game in enumerate(out,start=1):\n    max_cubes = get_max_cubes(game)\n    if compare_require(max_cubes,require_cubes):\n        index_sum+=index\nindex_sum\n\n2204",
    "crumbs": [
      "2023",
      "Day 2"
    ]
  },
  {
    "objectID": "2023/Day_2.html#part-2",
    "href": "2023/Day_2.html#part-2",
    "title": "Day 2",
    "section": "Part 2",
    "text": "Part 2\nAs you continue your walk, the Elf poses a second question: in each game you played, what is the fewest number of cubes of each color that could have been in the bag to make the game possible?\nAgain consider the example games from earlier:\nGame 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green\nGame 2: 1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue\nGame 3: 8 green, 6 blue, 20 red; 5 blue, 4 red, 13 green; 5 green, 1 red\nGame 4: 1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, 15 blue, 14 red\nGame 5: 6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green\nIn game 1, the game could have been played with as few as 4 red, 2 green, and 6 blue cubes. If any color had even one fewer cube, the game would have been impossible. Game 2 could have been played with a minimum of 1 red, 3 green, and 4 blue cubes. Game 3 must have been played with at least 20 red, 13 green, and 6 blue cubes. Game 4 required at least 14 red, 3 green, and 15 blue cubes. Game 5 needed no fewer than 6 red, 3 green, and 2 blue cubes in the bag. The power of a set of cubes is equal to the numbers of red, green, and blue cubes multiplied together. The power of the minimum set of cubes in game 1 is 48. In games 2-5 it was 12, 1560, 630, and 36, respectively. Adding up these five powers produces the sum 2286.\nAI Prompt\ngiven a dictionary like “{‘red’: 4, ‘green’: 2, ‘blue’: 6}”, how to get the number multiply together?\nAI Response\nTo multiply the values in a dictionary together, you can use either a loop or the math.prod() function with dictionary values. Here’s a simple way:\nd = {'red': 4, 'green': 2, 'blue': 6}\nresult = 1\nfor value in d.values():\n    result *= value\nOr more concisely:\nfrom math import prod\nresult = prod(d.values())\nWould you like to try one of these approaches?\n\nsingle_dict\n\n{'green': 2}\n\n\n\nmax_cubes\n\n{'red': 15, 'green': 8, 'blue': 1}\n\n\n\nmax_cubes.values()\n\ndict_values([15, 8, 1])\n\n\n\nfrom math import prod\nprod(max_cubes.values())\n\n120\n\n\n\nproduct_sum = 0\nfor game in out:\n    max_cubes = get_max_cubes(game)\n    product = prod(max_cubes.values())\n    product_sum+=product\nproduct_sum\n\n71036",
    "crumbs": [
      "2023",
      "Day 2"
    ]
  },
  {
    "objectID": "2023/day_3.html",
    "href": "2023/day_3.html",
    "title": "For checking positions around the number:",
    "section": "",
    "text": "The engine schematic (your puzzle input) consists of a visual representation of the engine. There are lots of numbers and symbols you don’t really understand, but apparently any number adjacent to a symbol, even diagonally, is a “part number” and should be included in your sum. (Periods (.) do not count as a symbol.)\nHere is an example engine schematic:\n467..114..\n...*......\n..35..633.\n......#...\n617*......\n.....+.58.\n..592.....\n......755.\n...$.*....\n.664.598..\nIn this schematic, two numbers are not part numbers because they are not adjacent to a symbol: 114 (top right) and 58 (middle right). Every other number is adjacent to a symbol and so is a part number; their sum is 4361.\nOf course, the actual engine schematic is much larger. What is the sum of all of the part numbers in the engine schematic?\n\nsample = '''\n467..114..\n...*......\n..35..633.\n......#...\n617*......\n.....+.58.\n..592.....\n......755.\n...$.*....\n.664.598..\n'''\n\n\nnums = [467,114,35,633,617,58,592,755,664,598]\n\n\nnums.remove(114)\n\n\nnums.remove(58)\n\n\nnums\n\n[467, 35, 633, 617, 592, 755, 664, 598]\n\n\n\nsum(nums)\n\n4361\n\n\nAI Prompt\nwhat’s next?\nAI Response\nI notice you’ve worked through the example and successfully calculated the sum of part numbers (4361) after removing the non-part numbers (114 and 58).\nNow we need to solve this for the actual puzzle input. Would you like to: 1. Load and parse the actual input file, or 2. First work on creating a function that can automatically detect which numbers are part numbers (adjacent to symbols)?\nWhich would you prefer to tackle first?\nAI Prompt\n2\nAI Response\nOK, let’s work on creating a function to detect part numbers. Let’s break this down into steps:\n\nFirst, we need to identify what counts as a symbol (anything except digits and periods)\nThen, we need to check all 8 adjacent positions around each digit of a number\nIf any of those positions contains a symbol, the entire number is a part number\n\nWould you like to start by writing a function to identify symbols? We could create a simple helper function that returns True if a character is a symbol.\nWould you like to try writing this function first?\n\na = '.....+.58.'\n\n\n[o for o in a if a.isdigit()]\n\n[]\n\n\n\n[o for o in a]\n\n['.', '.', '.', '.', '.', '+', '.', '5', '8', '.']\n\n\n\nfor o in a:\n    print(a.isdigit())\n\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n\nfor o in a:\n    print(a.isnumeric())\n\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nAI Prompt\nhow to know if it is a symbol\nAI Response\nI notice you’re trying to check digits, but you’re using a.isdigit() which checks the whole string. Let’s check each character individually.\nTo identify a symbol, we need something that is: - Not a digit (0-9) - Not a period (.)\nHere’s a way to test one character:\ndef is_symbol(char):\n    return not (char.isdigit() or char == '.')\nWould you like to try this function on some sample characters to see if it works?\n\n[o for o in a if o.isdigit()]\n\n['5', '8']\n\n\n\n[o for o in a if not o.isdigit()]\n\n['.', '.', '.', '.', '.', '+', '.', '.']\n\n\n\n[o for o in a if not o.isdigit() or o!='.']\n\n['.', '.', '.', '.', '.', '+', '.', '5', '8', '.']\n\n\n\n[o for o in a if not o.isdigit() or o=='.']\n\n['.', '.', '.', '.', '.', '+', '.', '.']\n\n\n\n[o for o in a if o!='.']\n\n['+', '5', '8']\n\n\n\n[o for o in a if not o.isdigit() and o!='.']\n\n['+']\n\n\n\ndef is_symbol(char):\n    return not (char.isdigit() or char == '.')\n\n\nis_symbol(a)\n\nTrue\n\n\n\nfor o in a:\n    print(o)\n    print(is_symbol(o))\n\n.\nFalse\n.\nFalse\n.\nFalse\n.\nFalse\n.\nFalse\n+\nTrue\n.\nFalse\n5\nFalse\n8\nFalse\n.\nFalse\n\n\nAI Prompt\nwhat’s next?\nAI Response\nGreat! You’ve successfully created and tested the is_symbol function. Now we need to:\n\nCheck all 8 positions around a number for symbols (up, down, left, right, and all diagonals)\nFirst though, we need to convert our input into a format where we can easily access positions. A 2D list/grid might work well here.\n\nWould you like to try converting the sample input into a 2D grid first? We can use the sample string we had earlier and split it into rows.\nWould you like to try this, or would you like some hints on how to do it?\nAI Prompt\ngive me some hints on how to do it\nAI Response\nHere are some hints for converting the input into a 2D grid:\n\nFirst, look at the sample string - notice it has newlines () between rows\nYou can use .strip() to remove any extra whitespace/newlines at the start/end\nThen .split('\\n') will give you a list of rows\nEach row is a string that you can treat like a list of characters\n\nWould you like to try using these hints to create the grid from our sample input? We can test it with a small print statement to make sure it looks right.\n\nsample\n\n'\\n467..114..\\n...*......\\n..35..633.\\n......#...\\n617*......\\n.....+.58.\\n..592.....\\n......755.\\n...$.*....\\n.664.598..\\n'\n\n\n\nsample\n\n'\\n467..114..\\n...*......\\n..35..633.\\n......#...\\n617*......\\n.....+.58.\\n..592.....\\n......755.\\n...$.*....\\n.664.598..\\n'\n\n\n\nsample.strip()\n\n'467..114..\\n...*......\\n..35..633.\\n......#...\\n617*......\\n.....+.58.\\n..592.....\\n......755.\\n...$.*....\\n.664.598..'\n\n\n\nsample.strip().splitlines()\n\n['467..114..',\n '...*......',\n '..35..633.',\n '......#...',\n '617*......',\n '.....+.58.',\n '..592.....',\n '......755.',\n '...$.*....',\n '.664.598..']\n\n\n\ndef preprocess_raw(inp):\n    return inp.strip().splitlines()\n\n\npreprocess_raw(sample)\n\n['467..114..',\n '...*......',\n '..35..633.',\n '......#...',\n '617*......',\n '.....+.58.',\n '..592.....',\n '......755.',\n '...$.*....',\n '.664.598..']\n\n\nAI Prompt\nwhat’s next?\nAI Response\nGreat! You’ve got the grid structure set up. Now we need to find numbers and check if they’re adjacent to symbols.\nFor each number, we’ll need to: 1. Find where it starts and ends in a row 2. Check all positions around those digits for symbols (including diagonals)\nWould you like to start by writing code to find the numbers in a row? We could write a function that takes a row string and returns the positions of all numbers in it.\nWould you like to try this, or would you like some hints?\n\ndef get_row_digit_position(row):\n    indexes=[]\n    for char in row:\n        if char.isdigit():\n            indexes.append(row.index(char))\n\n\nget_row_digit_position('.2....456')\n\n\ndef get_row_digit_position(row):\n    indexes=[]\n    for char in row:\n        if char.isdigit():\n            indexes.append(row.index(char))\n    return indexes\n\n\nget_row_digit_position('.2....456')\n\n[1, 6, 7, 8]\n\n\nAI Prompt\nwhat’s next?\nAI Response\nI notice that your function has a small issue - using row.index(char) will always give you the first occurrence of a digit in the string. For example, if you had ‘..22..’, both 2’s would show the same position.\nLet’s modify the function to track the actual position as we go through the string. Would you like to try this approach: 1. Use enumerate() to get both the character and its position 2. Store both the position and the digit when we find one\nWould you like to try modifying your function, or would you like some hints?\n\ndef get_row_digit_position(row):\n    indexes=[]\n    for index, char in enumerate(row):\n        if char.isdigit():\n            indexes.append(index)\n    return indexes\n\n\nget_row_digit_position('..22..')\n\n[2, 3]\n\n\nAI Prompt\nmodified, what’s next?\nAI Response\nGreat! Now we need to identify complete numbers, not just individual digits. For example, in ‘..22..’ we want to know that there’s one number (22) at positions 2-3, not two separate digits.\nWe need to look for consecutive digits and group them together. When we find a digit, we should: 1. Check if it’s connected to the previous digit 2. If yes, add it to that number 3. If no, start a new number\nWould you like to try modifying your function to group consecutive digits, or would you like some hints on how to do this?\nAI Prompt\ngive me a hint to modify the function\nAI Response\nHere’s a hint: You can detect if digits are part of the same number by checking if their positions are consecutive.\nFor example, if you have the indexes [2,3,6,7,8]: - 2 and 3 are consecutive (difference of 1) so they’re one number - Then there’s a gap - 6,7,8 are consecutive so they’re another number\nYou might want to: 1. Keep track of the start position of the current number 2. When you find a gap (difference &gt; 1), that means the previous number is complete 3. Store both the start and end positions of each complete number\nWould you like to try implementing this, or would you like more specific hints?\nAI Prompt\nshould I write a separate function or modify the existing get_row_digit_position\nAI Response\nI’d recommend writing a new function that uses get_row_digit_position as a helper function. This follows good programming practice of having each function do one specific thing:\n\nget_row_digit_position finds individual digit positions\nNew function will group these positions into complete numbers\n\nThis way, each function is simpler and easier to test. Would you like to try writing this new function, or would you like some hints on how to structure it?\nAI Prompt\nhow to find a gap(different &gt;1) in a list of numbers\nAI Response\nThere are a few ways to find gaps in a list of numbers. Here’s one approach:\nYou can compare each number with the next number in the list using a loop. For example, with indexes [2,3,6,7,8]: 1. Compare 2 with 3: 3-2 = 1 (no gap) 2. Compare 3 with 6: 6-3 = 3 (gap found!) 3. Compare 6 with 7: 7-6 = 1 (no gap) 4. Compare 7 with 8: 8-7 = 1 (no gap)\nYou can use zip() with slicing to look at pairs of numbers:\nnumbers = [2,3,6,7,8]\nfor curr, next_num in zip(numbers, numbers[1:]):\n    if next_num - curr &gt; 1:\n        print(f\"Found gap between {curr} and {next_num}\")\nWould you like to try using this approach in your function?\n\nnumbers = [2,3,6,7,8]\nfor curr, next_num in zip(numbers, numbers[1:]):\n    if next_num - curr &gt; 1:\n        print(f\"Found gap between {curr} and {next_num}\")\n\nFound gap between 3 and 6\n\n\nAI Prompt\nor use regex to extract number from row?\nAI Response\nYes, using regex is another good approach! It might actually be simpler since regex can directly find consecutive digits. Here’s a hint for using regex:\n\nYou’ll want to use re.finditer() which will give you both the numbers and their positions\nThe pattern \\d+ will match one or more consecutive digits\nEach match object will give you both:\n\nThe number (match.group())\nIts position (match.start() and match.end())\n\n\nWould you like to try writing a function using regex, or would you like to see an example pattern first?\n\nimport re\n\n\nre.finditer?\n\nSignature: re.finditer(pattern, string, flags=0)\nDocstring:\nReturn an iterator over all non-overlapping matches in the\nstring.  For each match, the iterator returns a Match object.\n\nEmpty matches are included in the result.\nFile:      /usr/local/lib/python3.11/re/__init__.py\nType:      function\n\n\n\nre.finditer('\\d+','...23..1')\n\n&lt;callable_iterator at 0x708bbd7e3070&gt;\n\n\n\n[o for o in re.finditer('\\d+','...23..1')]\n\n[&lt;re.Match object; span=(3, 5), match='23'&gt;,\n &lt;re.Match object; span=(7, 8), match='1'&gt;]\n\n\nAI Prompt\nhow to use regex to find number?\nAI Response\nLet’s break this down. From your test, we can see that re.finditer() returns match objects. Here’s how to extract the useful information from each match:\ntest_str = '...23..1'\nfor match in re.finditer('\\d+', test_str):\n    number = int(match.group())  # the actual number\n    start = match.start()        # starting position\n    end = match.end()           # ending position\n    print(f\"Found number {number} at positions {start}-{end}\")\nWould you like to try this out and then turn it into a function that returns this information in a useful format?\n\ntest_str = '...23..1'\nfor match in re.finditer('\\d+', test_str):\n    number = int(match.group())  # the actual number\n    start = match.start()        # starting position\n    end = match.end()           # ending position\n    print(f\"Found number {number} at positions {start}-{end}\")\n\nFound number 23 at positions 3-5\nFound number 1 at positions 7-8\n\n\nAI Prompt\nwhich return format is good?\nAI Response\nFor this puzzle, we’ll need both the numbers and their positions to check for adjacent symbols. Here are some possible return formats:\n\nList of tuples: [(number, start, end), ...]\n[(23, 3, 5), (1, 7, 8)]\nList of dictionaries: [{'number': n, 'start': s, 'end': e}, ...]\n[{'number': 23, 'start': 3, 'end': 5}, {'number': 1, 'start': 7, 'end': 8}]\n\nThe tuple format is more concise, while the dictionary format is more readable.\nWhich format would you prefer to work with?\n\ndef get_num_position(row):\n\n    for match in re.finditer('\\d+', row):\n        number = int(match.group())  # the actual number\n        start = match.start()        # starting position\n        end = match.end()           # ending position\n    return dict(number=number,start=start,end=end)\n\n\nget_num_position('..2..33')\n\n{'number': 33, 'start': 5, 'end': 7}\n\n\n\ndef get_num_position(row):\n    dicts = []\n    for match in re.finditer('\\d+', row):\n        number = int(match.group())  # the actual number\n        start = match.start()        # starting position\n        end = match.end()           # ending position\n        dicts.append(dict(number=number,start=start,end=end))\n    return dicts\n\n\nget_num_position('..2..33')\n\n[{'number': 2, 'start': 2, 'end': 3}, {'number': 33, 'start': 5, 'end': 7}]\n\n\nAI Prompt\nwhat’s next?\nAI Response\nGreat! Now that we can find numbers and their positions in a row, we need to:\n\nCheck if each number is adjacent to any symbols (including diagonally)\nFor this, we’ll need to look at:\n\nThe row above (if it exists)\nThe same row\nThe row below (if it exists)\n\n\nWould you like to write a function that checks if a number is adjacent to any symbols? We can use our existing is_symbol function to help with this.\nWould you like to try this, or would you like some hints on how to check the adjacent positions?\n\nis_symbol?\n\nSignature: is_symbol(char)\nDocstring: &lt;no docstring&gt;\nFile:      ~/&lt;ipython-input-1-f7baa4904f7b&gt;\nType:      function\n\n\n\nis_symbol??\n\nSignature: is_symbol(char)\nDocstring: &lt;no docstring&gt;\nSource:   \ndef is_symbol(char):\n    return not (char.isdigit() or char == '.')\nFile:      ~/&lt;ipython-input-1-f7baa4904f7b&gt;\nType:      function\n\n\nAI Prompt\ngive me hints on how to check the adjacent positions?\nAI Response\nHere’s how we can think about checking adjacent positions:\nFor a number that starts at position start and ends at position end, we need to check:\n\nOne position before start and one position after end in the same row\nFor the row above and below, check all positions from:\n\n(start-1) to (end+1)\n\n\nFor example, if we have “..23.” and 23 is at positions 2-3:\nCheck positions:\nRow above: 1,2,3,4\nSame row: 1,4\nRow below: 1,2,3,4\nWould you like to try writing a function that takes: - The current row - The row above (if any) - The row below (if any) - The start and end positions of a number\nAnd returns whether any adjacent position contains a symbol?\n\nsample\n\n'\\n467..114..\\n...*......\\n..35..633.\\n......#...\\n617*......\\n.....+.58.\\n..592.....\\n......755.\\n...$.*....\\n.664.598..\\n'\n\n\n\nxs = preprocess_raw(sample)\n\n\nxs\n\n['467..114..',\n '...*......',\n '..35..633.',\n '......#...',\n '617*......',\n '.....+.58.',\n '..592.....',\n '......755.',\n '...$.*....',\n '.664.598..']\n\n\n\nxs[0][1]\n\n'6'\n\n\n\ndict_one = {'number': 33, 'start': 5, 'end': 7}\nindex = 1\n\nAI Prompt\ngive me a hint on how to check adajacent?\n\nrow_start = dict_one['start'] - 1    # one position before number\nrow_end = dict_one['end'] + 1      # one position after number\n\n\nxs[index-1][row_start:row_end+1],xs[index][row_start],xs[index][row_end], xs[index+1][row_start:row_end+1]\n\n('.114.', '.', '.', '..633')\n\n\n\nxs[0][5:20]\n\n'114..'\n\n\n\nxs[0][-5:2]\n\n''\n\n\n\nxs[0]\n\n'467..114..'\n\n\n\nxs[0][-1:5]\n\n''\n\n\nAI Prompt\nhow to make it become a function?\nAI Response\nLet’s create a function that checks for adjacent symbols. Here’s a suggested structure:\ndef has_adjacent_symbol(grid, row_idx, number_dict):\n    \"\"\"\n    grid: list of rows (xs in your case)\n    row_idx: which row the number is in\n    number_dict: dictionary with 'start' and 'end' positions\n    \"\"\"\n    row_start = max(0, number_dict['start'] - 1)  # don't go below 0\n    row_end = min(len(grid[0]), number_dict['end'] + 1)  # don't go past end\n    \n    # Check above row if it exists\n    if row_idx &gt; 0:\n        above = grid[row_idx-1][row_start:row_end+1]\n        # check for symbols in above\n        \n    # Check current row (just the ends)\n    current = grid[row_idx][row_start], grid[row_idx][row_end]\n    \n    # Check below row if it exists\n    if row_idx &lt; len(grid)-1:\n        below = grid[row_idx+1][row_start:row_end+1]\n        # check for symbols in below\n\n    return # True if any symbols found\nWould you like to try completing this function? I can help with any specific part you’re unsure about.\n\ndef has_adjacent_symbol(grid, row_idx, number_dict):\n    \"\"\"\n    grid: list of rows\n    row_idx: which row the number is in\n    number_dict: dictionary with 'start' and 'end' positions\n    \"\"\"\n    row_start = max(0, number_dict['start'] - 1)  # don't go below 0\n    row_end = min(len(grid[0]), number_dict['end'] + 1)  # don't go past end\n    \n    # Check above row if it exists\n    if row_idx &gt; 0:\n        above = grid[row_idx-1][row_start:row_end+1]\n        # check for symbols in above\n        \n    # Check current row (just the ends)\n    current = grid[row_idx][row_start], grid[row_idx][row_end]\n    \n    # Check below row if it exists\n    if row_idx &lt; len(grid)-1:\n        below = grid[row_idx+1][row_start:row_end+1]\n        # check for symbols in below\n\n    return above,current,below\n\n\ndict_one\n\n{'number': 33, 'start': 5, 'end': 7}\n\n\n\nrow = xs[1]\n\n\nget_row_digit_position(row)\n\n[]\n\n\n\n# get_row_digit_position\n\n\nget_row_digit_position?\n\nSignature: get_row_digit_position(row)\nDocstring: &lt;no docstring&gt;\nFile:      ~/&lt;ipython-input-1-c808883576b3&gt;\nType:      function\n\n\n\nget_row_digit_position??\n\nSignature: get_row_digit_position(row)\nDocstring: &lt;no docstring&gt;\nSource:   \ndef get_row_digit_position(row):\n    indexes=[]\n    for index, char in enumerate(row):\n        if char.isdigit():\n            indexes.append(index)\n    return indexes\nFile:      ~/&lt;ipython-input-1-c808883576b3&gt;\nType:      function\n\n\n\nrow\n\n'...*......'\n\n\n\nrow = xs[2]\nrow\n\n'..35..633.'\n\n\n\nget_row_digit_position(row)\n\n[2, 3, 6, 7, 8]\n\n\n\nget_num_position??\n\nSignature: get_num_position(row)\nDocstring: &lt;no docstring&gt;\nSource:   \ndef get_num_position(row):\n    dicts = []\n    for match in re.finditer('\\d+', row):\n        number = int(match.group())  # the actual number\n        start = match.start()        # starting position\n        end = match.end()           # ending position\n        dicts.append(dict(number=number,start=start,end=end))\n    return dicts\nFile:      ~/&lt;ipython-input-1-b591f7575837&gt;\nType:      function\n\n\n\nget_num_position(row)\n\n[{'number': 35, 'start': 2, 'end': 4}, {'number': 633, 'start': 6, 'end': 9}]\n\n\n\nrow_dicts = get_num_position(row)\n\n\ndict_one = row_dicts[0]\n\n\nrow_index=2\n\n\nhas_adjacent_symbol?\n\nSignature: has_adjacent_symbol(grid, row_idx, number_dict)\nDocstring:\ngrid: list of rows\nrow_idx: which row the number is in\nnumber_dict: dictionary with 'start' and 'end' positions\nFile:      ~/&lt;ipython-input-1-8f0094edfba7&gt;\nType:      function\n\n\n\nhas_adjacent_symbol(xs,2,dict_one)\n\n('..*..', ('.', '.'), '.....')\n\n\n\nis_symbol??\n\nSignature: is_symbol(char)\nDocstring: &lt;no docstring&gt;\nSource:   \ndef is_symbol(char):\n    return not (char.isdigit() or char == '.')\nFile:      ~/&lt;ipython-input-1-f7baa4904f7b&gt;\nType:      function\n\n\n\ndef check_symbol(strings):\n    for char in strings:\n        if not (char.isdigit() or char == '.'):\n            return True\n    return False\n\n\ncheck_symbol('..*..')\n\nTrue\n\n\n\ncheck_symbol(('.', '.'))\n\nFalse\n\n\n\nfor i in ('.', '.'): print(i)\n\n.\n.\n\n\nAI Prompt\nis check_symbol good?\nAI Response\nYes, check_symbol looks good! It: 1. Takes either a string or an iterable of characters 2. Returns True if any character is a symbol (not a digit and not a period) 3. Returns False if no symbols are found\nNow we can modify our has_adjacent_symbol function to use check_symbol on: - The above row - The current row ends - The below row\nWould you like to try updating the has_adjacent_symbol function to use check_symbol?\nAI Prompt\nhelp me update\nAI Response\nHere’s how we can update the function step by step:\ndef has_adjacent_symbol(grid, row_idx, number_dict):\n    row_start = max(0, number_dict['start'] - 1)  # don't go below 0\n    row_end = min(len(grid[0]), number_dict['end'] + 1)  # don't go past end\n    \n    # Check above row if it exists\n    if row_idx &gt; 0:\n        above = grid[row_idx-1][row_start:row_end+1]\n        if check_symbol(above):\n            return True\n    \n    # Check current row (just the ends)\n    current = grid[row_idx][row_start], grid[row_idx][row_end]\n    if check_symbol(current):\n        return True\n    \n    # Check below row if it exists\n    if row_idx &lt; len(grid)-1:\n        below = grid[row_idx+1][row_start:row_end+1]\n        if check_symbol(below):\n            return True\n            \n    return False\nWould you like to try this out with your example to see if it correctly identifies numbers adjacent to symbols?\n\ndef has_adjacent_symbol(grid, row_idx, number_dict):\n    row_start = max(0, number_dict['start'] - 1)  # don't go below 0\n    row_end = min(len(grid[0]), number_dict['end'] + 1)  # don't go past end\n    \n    # Check above row if it exists\n    if row_idx &gt; 0:\n        above = grid[row_idx-1][row_start:row_end+1]\n        if check_symbol(above):\n            return True\n    \n    # Check current row (just the ends)\n    current = grid[row_idx][row_start], grid[row_idx][row_end]\n    if check_symbol(current):\n        return True\n    \n    # Check below row if it exists\n    if row_idx &lt; len(grid)-1:\n        below = grid[row_idx+1][row_start:row_end+1]\n        if check_symbol(below):\n            return True\n            \n    return False\n\n\nhas_adjacent_symbol(xs,2,dict_one)\n\nTrue\n\n\nAI Prompt\nwhat’s next?\nAI Response\nGreat! Now that we have all the pieces working: 1. get_num_position to find numbers in a row 2. has_adjacent_symbol to check if a number is adjacent to symbols\nWe need to: 1. Loop through each row in the grid 2. Find all numbers in that row 3. Check each number for adjacent symbols 4. Sum up the numbers that have adjacent symbols\nWould you like to try writing this main logic, or would you like some hints on how to structure it?\n\nget_num_position??\n\nSignature: get_num_position(row)\nDocstring: &lt;no docstring&gt;\nSource:   \ndef get_num_position(row):\n    dicts = []\n    for match in re.finditer('\\d+', row):\n        number = int(match.group())  # the actual number\n        start = match.start()        # starting position\n        end = match.end()           # ending position\n        dicts.append(dict(number=number,start=start,end=end))\n    return dicts\nFile:      ~/&lt;ipython-input-1-b591f7575837&gt;\nType:      function\n\n\n\nnums=[]\nfor row in xs:\n    row_dicts = get_num_position(row)\n    for row_dict in row_dicts:\n        if has_adjacent_symbol(xs,2,dict_one):\n            nums.append(row_dict['number'])\n\nnums\n\n[467, 114, 35, 633, 617, 58, 592, 755, 664, 598]\n\n\n\nnums=[]\nfor row_index, row in enumerate(xs):\n    row_dicts = get_num_position(row)\n    for row_dict in row_dicts:\n        if has_adjacent_symbol(xs,row_index,row_dict):\n            nums.append(row_dict['number'])\n\nnums\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[1], line 5\n      3     row_dicts = get_num_position(row)\n      4     for row_dict in row_dicts:\n----&gt; 5         if has_adjacent_symbol(xs,row_index,row_dict):\n      6             nums.append(row_dict['number'])\n      8 nums\n\nCell In[1], line 12, in has_adjacent_symbol(grid, row_idx, number_dict)\n      9         return True\n     11 # Check current row (just the ends)\n---&gt; 12 current = grid[row_idx][row_start], grid[row_idx][row_end]\n     13 if check_symbol(current):\n     14     return True\n\nIndexError: string index out of range\n\n\nIndexError: string index out of range\nTraceback (most recent call last):\n\n  File \"/usr/local/lib/python3.11/site-packages/IPython/core/interactiveshell.py\", line 3577, in run_code\n    exec(code_obj, self.user_global_ns, self.user_ns)\n\n  File \"&lt;ipython-input-1-a428d73095ab&gt;\", line 5, in &lt;module&gt;\n    if has_adjacent_symbol(xs,row_index,row_dict):\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n  File \"&lt;ipython-input-1-0382fd1e3b43&gt;\", line 12, in has_adjacent_symbol\n    current = grid[row_idx][row_start], grid[row_idx][row_end]\n                                        ~~~~~~~~~~~~~^^^^^^^^^\n\nIndexError: string index out of range\n\n\nAI Prompt\ngot this error\nAI Response\nAh, we have an index out of range error. This happens because we’re trying to access a position beyond the end of the string. Let’s fix the has_adjacent_symbol function:\n\nWe need to be more careful with the end position check\nWe should only check positions that exist in the string\n\nHere’s how we can modify the function:\ndef has_adjacent_symbol(grid, row_idx, number_dict):\n    row_length = len(grid[0])\n    row_start = max(0, number_dict['start'] - 1)  # don't go below 0\n    row_end = min(row_length - 1, number_dict['end'])  # don't go past last index\n    \n    # Check above row if it exists\n    if row_idx &gt; 0:\n        above = grid[row_idx-1][row_start:row_end+1]\n        if check_symbol(above):\n            return True\n    \n    # Check current row (just the ends, if they exist)\n    if row_start &lt; number_dict['start']:  # only check start if it exists\n        if check_symbol(grid[row_idx][row_start]):\n            return True\n    if row_end &gt; number_dict['end'] - 1:  # only check end if it exists\n        if check_symbol(grid[row_idx][row_end]):\n            return True\n    \n    # Check below row if it exists\n    if row_idx &lt; len(grid)-1:\n        below = grid[row_idx+1][row_start:row_end+1]\n        if check_symbol(below):\n            return True\n            \n    return False\nWould you like to try this updated version?\n\ndef has_adjacent_symbol(grid, row_idx, number_dict):\n    row_length = len(grid[0])\n    row_start = max(0, number_dict['start'] - 1)  # don't go below 0\n    row_end = min(row_length - 1, number_dict['end'])  # don't go past last index\n    \n    # Check above row if it exists\n    if row_idx &gt; 0:\n        above = grid[row_idx-1][row_start:row_end+1]\n        if check_symbol(above):\n            return True\n    \n    # Check current row (just the ends, if they exist)\n    if row_start &lt; number_dict['start']:  # only check start if it exists\n        if check_symbol(grid[row_idx][row_start]):\n            return True\n    if row_end &gt; number_dict['end'] - 1:  # only check end if it exists\n        if check_symbol(grid[row_idx][row_end]):\n            return True\n    \n    # Check below row if it exists\n    if row_idx &lt; len(grid)-1:\n        below = grid[row_idx+1][row_start:row_end+1]\n        if check_symbol(below):\n            return True\n            \n    return False\n\n\nnums=[]\nfor row_index, row in enumerate(xs):\n    row_dicts = get_num_position(row)\n    for row_dict in row_dicts:\n        if has_adjacent_symbol(xs,row_index,row_dict):\n            nums.append(row_dict['number'])\n\nnums\n\n[467, 35, 633, 617, 592, 755, 664, 598]\n\n\nAI Prompt\nwhat’s the difference after the update? why it works now\nAI Response\nThe key differences in the updated version that fixed the error are:\n\nBefore: We were trying to access grid[row_idx][row_end] directly, which could be beyond the string length Now: We use min(row_length - 1, number_dict['end']) to ensure we never try to access beyond the string’s end\nBefore: We checked both ends of the current row at once with tuple unpacking Now: We check each end separately with conditions:\n\nif row_start &lt; number_dict['start'] - only check left edge if it exists\nif row_end &gt; number_dict['end'] - 1 - only check right edge if it exists\n\n\nLooking at the results: - Before: We got an IndexError - Now: We get [467, 35, 633, 617, 592, 755, 664, 598] - Notice 114 and 58 are not included (which is correct according to the puzzle rules - they’re not adjacent to symbols)\nWould you like to verify if this matches the expected answer from the puzzle example?\n\nfrom aocd import get_data\ninp = get_data(day=2,year=2023)\n\n\nxs = preprocess_raw(inp)\n\n\nxs[:4]\n\n['Game 1: 7 red, 14 blue; 2 blue, 3 red, 3 green; 4 green, 12 blue, 15 red; 3 green, 12 blue, 3 red; 11 red, 2 green',\n 'Game 2: 16 blue, 9 red, 5 green; 8 red; 8 blue, 5 green, 12 red; 11 blue, 8 green, 17 red',\n 'Game 3: 8 green, 1 blue, 7 red; 12 red, 6 blue, 9 green; 2 blue, 1 red, 14 green; 9 green, 4 red; 2 red, 1 blue, 8 green',\n 'Game 4: 1 blue, 3 green; 2 green, 1 blue, 1 red; 1 red, 3 green']\n\n\n\nfrom aocd import get_data\ninp = get_data(day=3,year=2023)\nxs = preprocess_raw(inp)\n\n\nxs[:3]\n\n['..............423....688..934............970................................95.728..........896...113..................153..972.............',\n '...122..................*.....*..........................919..509*..........&...@.........../...........................+.......*...........',\n '....+..........259....698..373.992.52.674.........................781...22........130.584.....-...%399.......777.................266........']\n\n\n\nnums=[]\nfor row_index, row in enumerate(xs):\n    row_dicts = get_num_position(row)\n    for row_dict in row_dicts:\n        if has_adjacent_symbol(xs,row_index,row_dict):\n            nums.append(row_dict['number'])\n\nsum(nums)\n\n538046",
    "crumbs": [
      "2023",
      "For checking positions around the number:"
    ]
  },
  {
    "objectID": "2023/day_3.html#day3",
    "href": "2023/day_3.html#day3",
    "title": "For checking positions around the number:",
    "section": "",
    "text": "The engine schematic (your puzzle input) consists of a visual representation of the engine. There are lots of numbers and symbols you don’t really understand, but apparently any number adjacent to a symbol, even diagonally, is a “part number” and should be included in your sum. (Periods (.) do not count as a symbol.)\nHere is an example engine schematic:\n467..114..\n...*......\n..35..633.\n......#...\n617*......\n.....+.58.\n..592.....\n......755.\n...$.*....\n.664.598..\nIn this schematic, two numbers are not part numbers because they are not adjacent to a symbol: 114 (top right) and 58 (middle right). Every other number is adjacent to a symbol and so is a part number; their sum is 4361.\nOf course, the actual engine schematic is much larger. What is the sum of all of the part numbers in the engine schematic?\n\nsample = '''\n467..114..\n...*......\n..35..633.\n......#...\n617*......\n.....+.58.\n..592.....\n......755.\n...$.*....\n.664.598..\n'''\n\n\nnums = [467,114,35,633,617,58,592,755,664,598]\n\n\nnums.remove(114)\n\n\nnums.remove(58)\n\n\nnums\n\n[467, 35, 633, 617, 592, 755, 664, 598]\n\n\n\nsum(nums)\n\n4361\n\n\nAI Prompt\nwhat’s next?\nAI Response\nI notice you’ve worked through the example and successfully calculated the sum of part numbers (4361) after removing the non-part numbers (114 and 58).\nNow we need to solve this for the actual puzzle input. Would you like to: 1. Load and parse the actual input file, or 2. First work on creating a function that can automatically detect which numbers are part numbers (adjacent to symbols)?\nWhich would you prefer to tackle first?\nAI Prompt\n2\nAI Response\nOK, let’s work on creating a function to detect part numbers. Let’s break this down into steps:\n\nFirst, we need to identify what counts as a symbol (anything except digits and periods)\nThen, we need to check all 8 adjacent positions around each digit of a number\nIf any of those positions contains a symbol, the entire number is a part number\n\nWould you like to start by writing a function to identify symbols? We could create a simple helper function that returns True if a character is a symbol.\nWould you like to try writing this function first?\n\na = '.....+.58.'\n\n\n[o for o in a if a.isdigit()]\n\n[]\n\n\n\n[o for o in a]\n\n['.', '.', '.', '.', '.', '+', '.', '5', '8', '.']\n\n\n\nfor o in a:\n    print(a.isdigit())\n\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n\nfor o in a:\n    print(a.isnumeric())\n\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nAI Prompt\nhow to know if it is a symbol\nAI Response\nI notice you’re trying to check digits, but you’re using a.isdigit() which checks the whole string. Let’s check each character individually.\nTo identify a symbol, we need something that is: - Not a digit (0-9) - Not a period (.)\nHere’s a way to test one character:\ndef is_symbol(char):\n    return not (char.isdigit() or char == '.')\nWould you like to try this function on some sample characters to see if it works?\n\n[o for o in a if o.isdigit()]\n\n['5', '8']\n\n\n\n[o for o in a if not o.isdigit()]\n\n['.', '.', '.', '.', '.', '+', '.', '.']\n\n\n\n[o for o in a if not o.isdigit() or o!='.']\n\n['.', '.', '.', '.', '.', '+', '.', '5', '8', '.']\n\n\n\n[o for o in a if not o.isdigit() or o=='.']\n\n['.', '.', '.', '.', '.', '+', '.', '.']\n\n\n\n[o for o in a if o!='.']\n\n['+', '5', '8']\n\n\n\n[o for o in a if not o.isdigit() and o!='.']\n\n['+']\n\n\n\ndef is_symbol(char):\n    return not (char.isdigit() or char == '.')\n\n\nis_symbol(a)\n\nTrue\n\n\n\nfor o in a:\n    print(o)\n    print(is_symbol(o))\n\n.\nFalse\n.\nFalse\n.\nFalse\n.\nFalse\n.\nFalse\n+\nTrue\n.\nFalse\n5\nFalse\n8\nFalse\n.\nFalse\n\n\nAI Prompt\nwhat’s next?\nAI Response\nGreat! You’ve successfully created and tested the is_symbol function. Now we need to:\n\nCheck all 8 positions around a number for symbols (up, down, left, right, and all diagonals)\nFirst though, we need to convert our input into a format where we can easily access positions. A 2D list/grid might work well here.\n\nWould you like to try converting the sample input into a 2D grid first? We can use the sample string we had earlier and split it into rows.\nWould you like to try this, or would you like some hints on how to do it?\nAI Prompt\ngive me some hints on how to do it\nAI Response\nHere are some hints for converting the input into a 2D grid:\n\nFirst, look at the sample string - notice it has newlines () between rows\nYou can use .strip() to remove any extra whitespace/newlines at the start/end\nThen .split('\\n') will give you a list of rows\nEach row is a string that you can treat like a list of characters\n\nWould you like to try using these hints to create the grid from our sample input? We can test it with a small print statement to make sure it looks right.\n\nsample\n\n'\\n467..114..\\n...*......\\n..35..633.\\n......#...\\n617*......\\n.....+.58.\\n..592.....\\n......755.\\n...$.*....\\n.664.598..\\n'\n\n\n\nsample\n\n'\\n467..114..\\n...*......\\n..35..633.\\n......#...\\n617*......\\n.....+.58.\\n..592.....\\n......755.\\n...$.*....\\n.664.598..\\n'\n\n\n\nsample.strip()\n\n'467..114..\\n...*......\\n..35..633.\\n......#...\\n617*......\\n.....+.58.\\n..592.....\\n......755.\\n...$.*....\\n.664.598..'\n\n\n\nsample.strip().splitlines()\n\n['467..114..',\n '...*......',\n '..35..633.',\n '......#...',\n '617*......',\n '.....+.58.',\n '..592.....',\n '......755.',\n '...$.*....',\n '.664.598..']\n\n\n\ndef preprocess_raw(inp):\n    return inp.strip().splitlines()\n\n\npreprocess_raw(sample)\n\n['467..114..',\n '...*......',\n '..35..633.',\n '......#...',\n '617*......',\n '.....+.58.',\n '..592.....',\n '......755.',\n '...$.*....',\n '.664.598..']\n\n\nAI Prompt\nwhat’s next?\nAI Response\nGreat! You’ve got the grid structure set up. Now we need to find numbers and check if they’re adjacent to symbols.\nFor each number, we’ll need to: 1. Find where it starts and ends in a row 2. Check all positions around those digits for symbols (including diagonals)\nWould you like to start by writing code to find the numbers in a row? We could write a function that takes a row string and returns the positions of all numbers in it.\nWould you like to try this, or would you like some hints?\n\ndef get_row_digit_position(row):\n    indexes=[]\n    for char in row:\n        if char.isdigit():\n            indexes.append(row.index(char))\n\n\nget_row_digit_position('.2....456')\n\n\ndef get_row_digit_position(row):\n    indexes=[]\n    for char in row:\n        if char.isdigit():\n            indexes.append(row.index(char))\n    return indexes\n\n\nget_row_digit_position('.2....456')\n\n[1, 6, 7, 8]\n\n\nAI Prompt\nwhat’s next?\nAI Response\nI notice that your function has a small issue - using row.index(char) will always give you the first occurrence of a digit in the string. For example, if you had ‘..22..’, both 2’s would show the same position.\nLet’s modify the function to track the actual position as we go through the string. Would you like to try this approach: 1. Use enumerate() to get both the character and its position 2. Store both the position and the digit when we find one\nWould you like to try modifying your function, or would you like some hints?\n\ndef get_row_digit_position(row):\n    indexes=[]\n    for index, char in enumerate(row):\n        if char.isdigit():\n            indexes.append(index)\n    return indexes\n\n\nget_row_digit_position('..22..')\n\n[2, 3]\n\n\nAI Prompt\nmodified, what’s next?\nAI Response\nGreat! Now we need to identify complete numbers, not just individual digits. For example, in ‘..22..’ we want to know that there’s one number (22) at positions 2-3, not two separate digits.\nWe need to look for consecutive digits and group them together. When we find a digit, we should: 1. Check if it’s connected to the previous digit 2. If yes, add it to that number 3. If no, start a new number\nWould you like to try modifying your function to group consecutive digits, or would you like some hints on how to do this?\nAI Prompt\ngive me a hint to modify the function\nAI Response\nHere’s a hint: You can detect if digits are part of the same number by checking if their positions are consecutive.\nFor example, if you have the indexes [2,3,6,7,8]: - 2 and 3 are consecutive (difference of 1) so they’re one number - Then there’s a gap - 6,7,8 are consecutive so they’re another number\nYou might want to: 1. Keep track of the start position of the current number 2. When you find a gap (difference &gt; 1), that means the previous number is complete 3. Store both the start and end positions of each complete number\nWould you like to try implementing this, or would you like more specific hints?\nAI Prompt\nshould I write a separate function or modify the existing get_row_digit_position\nAI Response\nI’d recommend writing a new function that uses get_row_digit_position as a helper function. This follows good programming practice of having each function do one specific thing:\n\nget_row_digit_position finds individual digit positions\nNew function will group these positions into complete numbers\n\nThis way, each function is simpler and easier to test. Would you like to try writing this new function, or would you like some hints on how to structure it?\nAI Prompt\nhow to find a gap(different &gt;1) in a list of numbers\nAI Response\nThere are a few ways to find gaps in a list of numbers. Here’s one approach:\nYou can compare each number with the next number in the list using a loop. For example, with indexes [2,3,6,7,8]: 1. Compare 2 with 3: 3-2 = 1 (no gap) 2. Compare 3 with 6: 6-3 = 3 (gap found!) 3. Compare 6 with 7: 7-6 = 1 (no gap) 4. Compare 7 with 8: 8-7 = 1 (no gap)\nYou can use zip() with slicing to look at pairs of numbers:\nnumbers = [2,3,6,7,8]\nfor curr, next_num in zip(numbers, numbers[1:]):\n    if next_num - curr &gt; 1:\n        print(f\"Found gap between {curr} and {next_num}\")\nWould you like to try using this approach in your function?\n\nnumbers = [2,3,6,7,8]\nfor curr, next_num in zip(numbers, numbers[1:]):\n    if next_num - curr &gt; 1:\n        print(f\"Found gap between {curr} and {next_num}\")\n\nFound gap between 3 and 6\n\n\nAI Prompt\nor use regex to extract number from row?\nAI Response\nYes, using regex is another good approach! It might actually be simpler since regex can directly find consecutive digits. Here’s a hint for using regex:\n\nYou’ll want to use re.finditer() which will give you both the numbers and their positions\nThe pattern \\d+ will match one or more consecutive digits\nEach match object will give you both:\n\nThe number (match.group())\nIts position (match.start() and match.end())\n\n\nWould you like to try writing a function using regex, or would you like to see an example pattern first?\n\nimport re\n\n\nre.finditer?\n\nSignature: re.finditer(pattern, string, flags=0)\nDocstring:\nReturn an iterator over all non-overlapping matches in the\nstring.  For each match, the iterator returns a Match object.\n\nEmpty matches are included in the result.\nFile:      /usr/local/lib/python3.11/re/__init__.py\nType:      function\n\n\n\nre.finditer('\\d+','...23..1')\n\n&lt;callable_iterator at 0x708bbd7e3070&gt;\n\n\n\n[o for o in re.finditer('\\d+','...23..1')]\n\n[&lt;re.Match object; span=(3, 5), match='23'&gt;,\n &lt;re.Match object; span=(7, 8), match='1'&gt;]\n\n\nAI Prompt\nhow to use regex to find number?\nAI Response\nLet’s break this down. From your test, we can see that re.finditer() returns match objects. Here’s how to extract the useful information from each match:\ntest_str = '...23..1'\nfor match in re.finditer('\\d+', test_str):\n    number = int(match.group())  # the actual number\n    start = match.start()        # starting position\n    end = match.end()           # ending position\n    print(f\"Found number {number} at positions {start}-{end}\")\nWould you like to try this out and then turn it into a function that returns this information in a useful format?\n\ntest_str = '...23..1'\nfor match in re.finditer('\\d+', test_str):\n    number = int(match.group())  # the actual number\n    start = match.start()        # starting position\n    end = match.end()           # ending position\n    print(f\"Found number {number} at positions {start}-{end}\")\n\nFound number 23 at positions 3-5\nFound number 1 at positions 7-8\n\n\nAI Prompt\nwhich return format is good?\nAI Response\nFor this puzzle, we’ll need both the numbers and their positions to check for adjacent symbols. Here are some possible return formats:\n\nList of tuples: [(number, start, end), ...]\n[(23, 3, 5), (1, 7, 8)]\nList of dictionaries: [{'number': n, 'start': s, 'end': e}, ...]\n[{'number': 23, 'start': 3, 'end': 5}, {'number': 1, 'start': 7, 'end': 8}]\n\nThe tuple format is more concise, while the dictionary format is more readable.\nWhich format would you prefer to work with?\n\ndef get_num_position(row):\n\n    for match in re.finditer('\\d+', row):\n        number = int(match.group())  # the actual number\n        start = match.start()        # starting position\n        end = match.end()           # ending position\n    return dict(number=number,start=start,end=end)\n\n\nget_num_position('..2..33')\n\n{'number': 33, 'start': 5, 'end': 7}\n\n\n\ndef get_num_position(row):\n    dicts = []\n    for match in re.finditer('\\d+', row):\n        number = int(match.group())  # the actual number\n        start = match.start()        # starting position\n        end = match.end()           # ending position\n        dicts.append(dict(number=number,start=start,end=end))\n    return dicts\n\n\nget_num_position('..2..33')\n\n[{'number': 2, 'start': 2, 'end': 3}, {'number': 33, 'start': 5, 'end': 7}]\n\n\nAI Prompt\nwhat’s next?\nAI Response\nGreat! Now that we can find numbers and their positions in a row, we need to:\n\nCheck if each number is adjacent to any symbols (including diagonally)\nFor this, we’ll need to look at:\n\nThe row above (if it exists)\nThe same row\nThe row below (if it exists)\n\n\nWould you like to write a function that checks if a number is adjacent to any symbols? We can use our existing is_symbol function to help with this.\nWould you like to try this, or would you like some hints on how to check the adjacent positions?\n\nis_symbol?\n\nSignature: is_symbol(char)\nDocstring: &lt;no docstring&gt;\nFile:      ~/&lt;ipython-input-1-f7baa4904f7b&gt;\nType:      function\n\n\n\nis_symbol??\n\nSignature: is_symbol(char)\nDocstring: &lt;no docstring&gt;\nSource:   \ndef is_symbol(char):\n    return not (char.isdigit() or char == '.')\nFile:      ~/&lt;ipython-input-1-f7baa4904f7b&gt;\nType:      function\n\n\nAI Prompt\ngive me hints on how to check the adjacent positions?\nAI Response\nHere’s how we can think about checking adjacent positions:\nFor a number that starts at position start and ends at position end, we need to check:\n\nOne position before start and one position after end in the same row\nFor the row above and below, check all positions from:\n\n(start-1) to (end+1)\n\n\nFor example, if we have “..23.” and 23 is at positions 2-3:\nCheck positions:\nRow above: 1,2,3,4\nSame row: 1,4\nRow below: 1,2,3,4\nWould you like to try writing a function that takes: - The current row - The row above (if any) - The row below (if any) - The start and end positions of a number\nAnd returns whether any adjacent position contains a symbol?\n\nsample\n\n'\\n467..114..\\n...*......\\n..35..633.\\n......#...\\n617*......\\n.....+.58.\\n..592.....\\n......755.\\n...$.*....\\n.664.598..\\n'\n\n\n\nxs = preprocess_raw(sample)\n\n\nxs\n\n['467..114..',\n '...*......',\n '..35..633.',\n '......#...',\n '617*......',\n '.....+.58.',\n '..592.....',\n '......755.',\n '...$.*....',\n '.664.598..']\n\n\n\nxs[0][1]\n\n'6'\n\n\n\ndict_one = {'number': 33, 'start': 5, 'end': 7}\nindex = 1\n\nAI Prompt\ngive me a hint on how to check adajacent?\n\nrow_start = dict_one['start'] - 1    # one position before number\nrow_end = dict_one['end'] + 1      # one position after number\n\n\nxs[index-1][row_start:row_end+1],xs[index][row_start],xs[index][row_end], xs[index+1][row_start:row_end+1]\n\n('.114.', '.', '.', '..633')\n\n\n\nxs[0][5:20]\n\n'114..'\n\n\n\nxs[0][-5:2]\n\n''\n\n\n\nxs[0]\n\n'467..114..'\n\n\n\nxs[0][-1:5]\n\n''\n\n\nAI Prompt\nhow to make it become a function?\nAI Response\nLet’s create a function that checks for adjacent symbols. Here’s a suggested structure:\ndef has_adjacent_symbol(grid, row_idx, number_dict):\n    \"\"\"\n    grid: list of rows (xs in your case)\n    row_idx: which row the number is in\n    number_dict: dictionary with 'start' and 'end' positions\n    \"\"\"\n    row_start = max(0, number_dict['start'] - 1)  # don't go below 0\n    row_end = min(len(grid[0]), number_dict['end'] + 1)  # don't go past end\n    \n    # Check above row if it exists\n    if row_idx &gt; 0:\n        above = grid[row_idx-1][row_start:row_end+1]\n        # check for symbols in above\n        \n    # Check current row (just the ends)\n    current = grid[row_idx][row_start], grid[row_idx][row_end]\n    \n    # Check below row if it exists\n    if row_idx &lt; len(grid)-1:\n        below = grid[row_idx+1][row_start:row_end+1]\n        # check for symbols in below\n\n    return # True if any symbols found\nWould you like to try completing this function? I can help with any specific part you’re unsure about.\n\ndef has_adjacent_symbol(grid, row_idx, number_dict):\n    \"\"\"\n    grid: list of rows\n    row_idx: which row the number is in\n    number_dict: dictionary with 'start' and 'end' positions\n    \"\"\"\n    row_start = max(0, number_dict['start'] - 1)  # don't go below 0\n    row_end = min(len(grid[0]), number_dict['end'] + 1)  # don't go past end\n    \n    # Check above row if it exists\n    if row_idx &gt; 0:\n        above = grid[row_idx-1][row_start:row_end+1]\n        # check for symbols in above\n        \n    # Check current row (just the ends)\n    current = grid[row_idx][row_start], grid[row_idx][row_end]\n    \n    # Check below row if it exists\n    if row_idx &lt; len(grid)-1:\n        below = grid[row_idx+1][row_start:row_end+1]\n        # check for symbols in below\n\n    return above,current,below\n\n\ndict_one\n\n{'number': 33, 'start': 5, 'end': 7}\n\n\n\nrow = xs[1]\n\n\nget_row_digit_position(row)\n\n[]\n\n\n\n# get_row_digit_position\n\n\nget_row_digit_position?\n\nSignature: get_row_digit_position(row)\nDocstring: &lt;no docstring&gt;\nFile:      ~/&lt;ipython-input-1-c808883576b3&gt;\nType:      function\n\n\n\nget_row_digit_position??\n\nSignature: get_row_digit_position(row)\nDocstring: &lt;no docstring&gt;\nSource:   \ndef get_row_digit_position(row):\n    indexes=[]\n    for index, char in enumerate(row):\n        if char.isdigit():\n            indexes.append(index)\n    return indexes\nFile:      ~/&lt;ipython-input-1-c808883576b3&gt;\nType:      function\n\n\n\nrow\n\n'...*......'\n\n\n\nrow = xs[2]\nrow\n\n'..35..633.'\n\n\n\nget_row_digit_position(row)\n\n[2, 3, 6, 7, 8]\n\n\n\nget_num_position??\n\nSignature: get_num_position(row)\nDocstring: &lt;no docstring&gt;\nSource:   \ndef get_num_position(row):\n    dicts = []\n    for match in re.finditer('\\d+', row):\n        number = int(match.group())  # the actual number\n        start = match.start()        # starting position\n        end = match.end()           # ending position\n        dicts.append(dict(number=number,start=start,end=end))\n    return dicts\nFile:      ~/&lt;ipython-input-1-b591f7575837&gt;\nType:      function\n\n\n\nget_num_position(row)\n\n[{'number': 35, 'start': 2, 'end': 4}, {'number': 633, 'start': 6, 'end': 9}]\n\n\n\nrow_dicts = get_num_position(row)\n\n\ndict_one = row_dicts[0]\n\n\nrow_index=2\n\n\nhas_adjacent_symbol?\n\nSignature: has_adjacent_symbol(grid, row_idx, number_dict)\nDocstring:\ngrid: list of rows\nrow_idx: which row the number is in\nnumber_dict: dictionary with 'start' and 'end' positions\nFile:      ~/&lt;ipython-input-1-8f0094edfba7&gt;\nType:      function\n\n\n\nhas_adjacent_symbol(xs,2,dict_one)\n\n('..*..', ('.', '.'), '.....')\n\n\n\nis_symbol??\n\nSignature: is_symbol(char)\nDocstring: &lt;no docstring&gt;\nSource:   \ndef is_symbol(char):\n    return not (char.isdigit() or char == '.')\nFile:      ~/&lt;ipython-input-1-f7baa4904f7b&gt;\nType:      function\n\n\n\ndef check_symbol(strings):\n    for char in strings:\n        if not (char.isdigit() or char == '.'):\n            return True\n    return False\n\n\ncheck_symbol('..*..')\n\nTrue\n\n\n\ncheck_symbol(('.', '.'))\n\nFalse\n\n\n\nfor i in ('.', '.'): print(i)\n\n.\n.\n\n\nAI Prompt\nis check_symbol good?\nAI Response\nYes, check_symbol looks good! It: 1. Takes either a string or an iterable of characters 2. Returns True if any character is a symbol (not a digit and not a period) 3. Returns False if no symbols are found\nNow we can modify our has_adjacent_symbol function to use check_symbol on: - The above row - The current row ends - The below row\nWould you like to try updating the has_adjacent_symbol function to use check_symbol?\nAI Prompt\nhelp me update\nAI Response\nHere’s how we can update the function step by step:\ndef has_adjacent_symbol(grid, row_idx, number_dict):\n    row_start = max(0, number_dict['start'] - 1)  # don't go below 0\n    row_end = min(len(grid[0]), number_dict['end'] + 1)  # don't go past end\n    \n    # Check above row if it exists\n    if row_idx &gt; 0:\n        above = grid[row_idx-1][row_start:row_end+1]\n        if check_symbol(above):\n            return True\n    \n    # Check current row (just the ends)\n    current = grid[row_idx][row_start], grid[row_idx][row_end]\n    if check_symbol(current):\n        return True\n    \n    # Check below row if it exists\n    if row_idx &lt; len(grid)-1:\n        below = grid[row_idx+1][row_start:row_end+1]\n        if check_symbol(below):\n            return True\n            \n    return False\nWould you like to try this out with your example to see if it correctly identifies numbers adjacent to symbols?\n\ndef has_adjacent_symbol(grid, row_idx, number_dict):\n    row_start = max(0, number_dict['start'] - 1)  # don't go below 0\n    row_end = min(len(grid[0]), number_dict['end'] + 1)  # don't go past end\n    \n    # Check above row if it exists\n    if row_idx &gt; 0:\n        above = grid[row_idx-1][row_start:row_end+1]\n        if check_symbol(above):\n            return True\n    \n    # Check current row (just the ends)\n    current = grid[row_idx][row_start], grid[row_idx][row_end]\n    if check_symbol(current):\n        return True\n    \n    # Check below row if it exists\n    if row_idx &lt; len(grid)-1:\n        below = grid[row_idx+1][row_start:row_end+1]\n        if check_symbol(below):\n            return True\n            \n    return False\n\n\nhas_adjacent_symbol(xs,2,dict_one)\n\nTrue\n\n\nAI Prompt\nwhat’s next?\nAI Response\nGreat! Now that we have all the pieces working: 1. get_num_position to find numbers in a row 2. has_adjacent_symbol to check if a number is adjacent to symbols\nWe need to: 1. Loop through each row in the grid 2. Find all numbers in that row 3. Check each number for adjacent symbols 4. Sum up the numbers that have adjacent symbols\nWould you like to try writing this main logic, or would you like some hints on how to structure it?\n\nget_num_position??\n\nSignature: get_num_position(row)\nDocstring: &lt;no docstring&gt;\nSource:   \ndef get_num_position(row):\n    dicts = []\n    for match in re.finditer('\\d+', row):\n        number = int(match.group())  # the actual number\n        start = match.start()        # starting position\n        end = match.end()           # ending position\n        dicts.append(dict(number=number,start=start,end=end))\n    return dicts\nFile:      ~/&lt;ipython-input-1-b591f7575837&gt;\nType:      function\n\n\n\nnums=[]\nfor row in xs:\n    row_dicts = get_num_position(row)\n    for row_dict in row_dicts:\n        if has_adjacent_symbol(xs,2,dict_one):\n            nums.append(row_dict['number'])\n\nnums\n\n[467, 114, 35, 633, 617, 58, 592, 755, 664, 598]\n\n\n\nnums=[]\nfor row_index, row in enumerate(xs):\n    row_dicts = get_num_position(row)\n    for row_dict in row_dicts:\n        if has_adjacent_symbol(xs,row_index,row_dict):\n            nums.append(row_dict['number'])\n\nnums\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[1], line 5\n      3     row_dicts = get_num_position(row)\n      4     for row_dict in row_dicts:\n----&gt; 5         if has_adjacent_symbol(xs,row_index,row_dict):\n      6             nums.append(row_dict['number'])\n      8 nums\n\nCell In[1], line 12, in has_adjacent_symbol(grid, row_idx, number_dict)\n      9         return True\n     11 # Check current row (just the ends)\n---&gt; 12 current = grid[row_idx][row_start], grid[row_idx][row_end]\n     13 if check_symbol(current):\n     14     return True\n\nIndexError: string index out of range\n\n\nIndexError: string index out of range\nTraceback (most recent call last):\n\n  File \"/usr/local/lib/python3.11/site-packages/IPython/core/interactiveshell.py\", line 3577, in run_code\n    exec(code_obj, self.user_global_ns, self.user_ns)\n\n  File \"&lt;ipython-input-1-a428d73095ab&gt;\", line 5, in &lt;module&gt;\n    if has_adjacent_symbol(xs,row_index,row_dict):\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n  File \"&lt;ipython-input-1-0382fd1e3b43&gt;\", line 12, in has_adjacent_symbol\n    current = grid[row_idx][row_start], grid[row_idx][row_end]\n                                        ~~~~~~~~~~~~~^^^^^^^^^\n\nIndexError: string index out of range\n\n\nAI Prompt\ngot this error\nAI Response\nAh, we have an index out of range error. This happens because we’re trying to access a position beyond the end of the string. Let’s fix the has_adjacent_symbol function:\n\nWe need to be more careful with the end position check\nWe should only check positions that exist in the string\n\nHere’s how we can modify the function:\ndef has_adjacent_symbol(grid, row_idx, number_dict):\n    row_length = len(grid[0])\n    row_start = max(0, number_dict['start'] - 1)  # don't go below 0\n    row_end = min(row_length - 1, number_dict['end'])  # don't go past last index\n    \n    # Check above row if it exists\n    if row_idx &gt; 0:\n        above = grid[row_idx-1][row_start:row_end+1]\n        if check_symbol(above):\n            return True\n    \n    # Check current row (just the ends, if they exist)\n    if row_start &lt; number_dict['start']:  # only check start if it exists\n        if check_symbol(grid[row_idx][row_start]):\n            return True\n    if row_end &gt; number_dict['end'] - 1:  # only check end if it exists\n        if check_symbol(grid[row_idx][row_end]):\n            return True\n    \n    # Check below row if it exists\n    if row_idx &lt; len(grid)-1:\n        below = grid[row_idx+1][row_start:row_end+1]\n        if check_symbol(below):\n            return True\n            \n    return False\nWould you like to try this updated version?\n\ndef has_adjacent_symbol(grid, row_idx, number_dict):\n    row_length = len(grid[0])\n    row_start = max(0, number_dict['start'] - 1)  # don't go below 0\n    row_end = min(row_length - 1, number_dict['end'])  # don't go past last index\n    \n    # Check above row if it exists\n    if row_idx &gt; 0:\n        above = grid[row_idx-1][row_start:row_end+1]\n        if check_symbol(above):\n            return True\n    \n    # Check current row (just the ends, if they exist)\n    if row_start &lt; number_dict['start']:  # only check start if it exists\n        if check_symbol(grid[row_idx][row_start]):\n            return True\n    if row_end &gt; number_dict['end'] - 1:  # only check end if it exists\n        if check_symbol(grid[row_idx][row_end]):\n            return True\n    \n    # Check below row if it exists\n    if row_idx &lt; len(grid)-1:\n        below = grid[row_idx+1][row_start:row_end+1]\n        if check_symbol(below):\n            return True\n            \n    return False\n\n\nnums=[]\nfor row_index, row in enumerate(xs):\n    row_dicts = get_num_position(row)\n    for row_dict in row_dicts:\n        if has_adjacent_symbol(xs,row_index,row_dict):\n            nums.append(row_dict['number'])\n\nnums\n\n[467, 35, 633, 617, 592, 755, 664, 598]\n\n\nAI Prompt\nwhat’s the difference after the update? why it works now\nAI Response\nThe key differences in the updated version that fixed the error are:\n\nBefore: We were trying to access grid[row_idx][row_end] directly, which could be beyond the string length Now: We use min(row_length - 1, number_dict['end']) to ensure we never try to access beyond the string’s end\nBefore: We checked both ends of the current row at once with tuple unpacking Now: We check each end separately with conditions:\n\nif row_start &lt; number_dict['start'] - only check left edge if it exists\nif row_end &gt; number_dict['end'] - 1 - only check right edge if it exists\n\n\nLooking at the results: - Before: We got an IndexError - Now: We get [467, 35, 633, 617, 592, 755, 664, 598] - Notice 114 and 58 are not included (which is correct according to the puzzle rules - they’re not adjacent to symbols)\nWould you like to verify if this matches the expected answer from the puzzle example?\n\nfrom aocd import get_data\ninp = get_data(day=2,year=2023)\n\n\nxs = preprocess_raw(inp)\n\n\nxs[:4]\n\n['Game 1: 7 red, 14 blue; 2 blue, 3 red, 3 green; 4 green, 12 blue, 15 red; 3 green, 12 blue, 3 red; 11 red, 2 green',\n 'Game 2: 16 blue, 9 red, 5 green; 8 red; 8 blue, 5 green, 12 red; 11 blue, 8 green, 17 red',\n 'Game 3: 8 green, 1 blue, 7 red; 12 red, 6 blue, 9 green; 2 blue, 1 red, 14 green; 9 green, 4 red; 2 red, 1 blue, 8 green',\n 'Game 4: 1 blue, 3 green; 2 green, 1 blue, 1 red; 1 red, 3 green']\n\n\n\nfrom aocd import get_data\ninp = get_data(day=3,year=2023)\nxs = preprocess_raw(inp)\n\n\nxs[:3]\n\n['..............423....688..934............970................................95.728..........896...113..................153..972.............',\n '...122..................*.....*..........................919..509*..........&...@.........../...........................+.......*...........',\n '....+..........259....698..373.992.52.674.........................781...22........130.584.....-...%399.......777.................266........']\n\n\n\nnums=[]\nfor row_index, row in enumerate(xs):\n    row_dicts = get_num_position(row)\n    for row_dict in row_dicts:\n        if has_adjacent_symbol(xs,row_index,row_dict):\n            nums.append(row_dict['number'])\n\nsum(nums)\n\n538046",
    "crumbs": [
      "2023",
      "For checking positions around the number:"
    ]
  },
  {
    "objectID": "2023/day_3.html#part-2",
    "href": "2023/day_3.html#part-2",
    "title": "For checking positions around the number:",
    "section": "Part 2",
    "text": "Part 2\nThis time, you need to find the gear ratio of every gear and add them all up so that the engineer can figure out which gear needs to be replaced.\nConsider the same engine schematic again:\n467..114..\n...*......\n..35..633.\n......#...\n617*......\n.....+.58.\n..592.....\n......755.\n...$.*....\n.664.598..\nIn this schematic, there are two gears. The first is in the top left; it has part numbers 467 and 35, so its gear ratio is 16345. The second gear is in the lower right; its gear ratio is 451490. (The * adjacent to 617 is not a gear because it is only adjacent to one part number.) Adding up all of the gear ratios produces 467835.\nWhat is the sum of all of the gear ratios in your engine schematic?\n\n467*35\n\n16345\n\n\n\n755*598\n\n451490\n\n\n\n16345+451490\n\n467835\n\n\n\nget_num_position??\n\nSignature: get_num_position(row)\nDocstring: &lt;no docstring&gt;\nSource:   \ndef get_num_position(row):\n    dicts = []\n    for match in re.finditer('\\d+', row):\n        number = int(match.group())  # the actual number\n        start = match.start()        # starting position\n        end = match.end()           # ending position\n        dicts.append(dict(number=number,start=start,end=end))\n    return dicts\nFile:      ~/&lt;ipython-input-1-b591f7575837&gt;\nType:      function\n\n\n\ndef get_star_positions(row):\n    positions = []\n    for position, char in enumerate(row):\n        if char == \"*\":\n            positions.append(position)\n    return positions\n\n\nget_star_positions('..*..*')\n\n[2, 5]\n\n\n\n('..*..*').index('*')\n\n2\n\n\n\n[o.index('*') for o in '..*..*']\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[1], line 1\n----&gt; 1 [o.index('*') for o in '..*..*']\n\nCell In[1], line 1, in &lt;listcomp&gt;(.0)\n----&gt; 1 [o.index('*') for o in '..*..*']\n\nValueError: substring not found\n\n\nValueError: substring not found\nTraceback (most recent call last):\n\n  File \"/usr/local/lib/python3.11/site-packages/IPython/core/interactiveshell.py\", line 3577, in run_code\n    exec(code_obj, self.user_global_ns, self.user_ns)\n\n  File \"&lt;ipython-input-1-aba2ac0a35ed&gt;\", line 1, in &lt;module&gt;\n    [o.index('*') for o in '..*..*']\n\n  File \"&lt;ipython-input-1-aba2ac0a35ed&gt;\", line 1, in &lt;listcomp&gt;\n    [o.index('*') for o in '..*..*']\n     ^^^^^^^^^^^^\n\nValueError: substring not found\n\n\n\nfor o in '..*..*': print(0)\n\n0\n0\n0\n0\n0\n0\n\n\n\nfor o in '..*..*': print(o)\n\n.\n.\n*\n.\n.\n*\n\n\n\ndef get_star_positions(row):\n    return [index for index, val in enumerate(row) if val == '*']\n\n\nget_star_positions(xs[1])\n\n[24, 30, 65, 128]\n\n\n\nxs[1]\n\n'...122..................*.....*..........................919..509*..........&...@.........../...........................+.......*...........'\n\n\n\nexample = '''\n467..114..\n...*......\n..35..633.\n......#...\n617*......\n.....+.58.\n..592.....\n......755.\n...$.*....\n.664.598..\n'''\n\n\nxxs = preprocess_raw(example)\n\n\nget_star_positions(xxs[1])\n\n[3]\n\n\nAI Prompt\nwhat’s next?\nAI Response\nFor Part 2, we need to:\n\nFind all ’*’ characters (potential gears) in each row\nFor each ’*’, check if it has exactly two adjacent numbers\nIf it does, multiply those two numbers together to get the gear ratio\nSum all the gear ratios\n\nWe’ve already got get_star_positions to find the ’*’ locations. Now we need to: 1. Write a function that finds all numbers adjacent to a star at a given position 2. Check if there are exactly two numbers adjacent to each star 3. Calculate and sum the gear ratios\nWould you like to start by writing a function to find numbers adjacent to a star at a given position? Or would you like some hints first?\nAI Prompt\ngive me hints for this function\nAI Response\nHere’s how we can think about finding numbers adjacent to a star:\n\nFor a star at position star_pos in row row_idx, we need to check:\n\nThe row above (row_idx - 1)\nThe current row (row_idx)\nThe row below (row_idx + 1)\n\nFor each number in these rows (using get_num_position), check if it’s adjacent by:\n\nLooking if any part of the number is within one position of the star\nExample: if star is at position 3, check if the number’s positions overlap with positions 2-4\n\nWe can test if a number overlaps these positions by checking if:\n\nnumber['start'] &lt;= star_pos + 1 (number starts before or at the position after the star)\nnumber['end'] - 1 &gt;= star_pos - 1 (number ends after or at the position before the star)\n\n\nWould you like to try implementing this logic, or would you like more specific hints?\nAI Prompt\nimplement the logic\nAI Response\nLet’s write a function that finds numbers adjacent to a star. Try this:\ndef find_adjacent_numbers(grid, row_idx, star_pos):\n    adjacent_numbers = []\n    \n    # Check the rows (above, current, and below)\n    for check_row in range(max(0, row_idx-1), min(len(grid), row_idx+2)):\n        numbers = get_num_position(grid[check_row])\n        \n        # For each number in the row, check if it's adjacent to the star\n        for number in numbers:\n            if (number['start'] &lt;= star_pos + 1 and \n                number['end'] - 1 &gt;= star_pos - 1):\n                adjacent_numbers.append(number['number'])\n                \n    return adjacent_numbers\nWould you like to test this function with our example data to see if it correctly identifies the numbers adjacent to each star?\n\ndef find_adjacent_numbers(grid, row_idx, star_pos):\n    adjacent_numbers = []\n    \n    # Check the rows (above, current, and below)\n    for check_row in range(max(0, row_idx-1), min(len(grid), row_idx+2)):\n        numbers = get_num_position(grid[check_row])\n        \n        # For each number in the row, check if it's adjacent to the star\n        for number in numbers:\n            if (number['start'] &lt;= star_pos + 1 and \n                number['end'] - 1 &gt;= star_pos - 1):\n                adjacent_numbers.append(number['number'])\n                \n    return adjacent_numbers\n\n\nall_nums = []\nfor row_idx, row in enumerate(xxs):\n    star_poses = get_star_positions(row)\n    for star_pos in star_poses:\n        nums = find_adjacent_numbers(xxs,row_idx,star_pos)\n        all_nums.append(nums)\n\nall_nums\n\n[[467, 35], [617], [755, 598]]\n\n\n\nall_nums = []\nfor row_idx, row in enumerate(xxs):\n    star_poses = get_star_positions(row)\n    for star_pos in star_poses:\n        nums = find_adjacent_numbers(xxs,row_idx,star_pos)\n        if len(nums) ==2:\n            all_nums.append(nums)\n\nall_nums\n\n[[467, 35], [755, 598]]\n\n\n\nfrom math import prod\nall_nums = []\nfor row_idx, row in enumerate(xxs):\n    star_poses = get_star_positions(row)\n    for star_pos in star_poses:\n        nums = find_adjacent_numbers(xxs,row_idx,star_pos)\n        if len(nums) ==2:\n            all_nums.append(prod(nums))\n\nall_nums\n\n[16345, 451490]\n\n\n\nfrom math import prod\nall_nums = []\nfor row_idx, row in enumerate(xs):\n    star_poses = get_star_positions(row)\n    for star_pos in star_poses:\n        nums = find_adjacent_numbers(xs,row_idx,star_pos)\n        if len(nums) ==2:\n            all_nums.append(prod(nums))\n\nsum(all_nums)\n\n81709807\n\n\nAI Prompt\nwhat’s this kind of usage “for number in numbers: if (number[‘start’] &lt;= star_pos + 1 and number[‘end’] - 1 &gt;= star_pos - 1): adjacent_numbers.append(number[‘number’])” I felt like amazing! is this use common?\nAI Response\nYes! This is a very common and powerful Python pattern that combines several useful concepts:\n\nDictionary access: Using number['start'] and number['end'] to access values in a dictionary\nRange comparison: Checking if a value falls within a range using two conditions:\n\nnumber['start'] &lt;= star_pos + 1 (is it starting before or at our right boundary?)\nnumber['end'] - 1 &gt;= star_pos - 1 (is it ending after or at our left boundary?)\n\nMulti-line conditions: Breaking a long condition across lines for readability using parentheses\n\nThis pattern is especially common when: - Working with positions or ranges (like in games or text processing) - Checking for overlaps between intervals - Processing geometric data\nWould you like to see some other examples of how this pattern can be used in different contexts?\nAI Prompt\nyes\nAI Response\nHere are some practical examples of similar patterns:\n\nChecking if two time periods overlap (like scheduling):\n\ndef has_time_conflict(meeting1, meeting2):\n    return (meeting1['start_time'] &lt;= meeting2['end_time'] and \n            meeting1['end_time'] &gt;= meeting2['start_time'])\n\nFinding objects within a certain distance in a game:\n\ndef is_in_range(player, target):\n    return (player['x'] - target['x'])**2 + (player['y'] - target['y'])**2 &lt;= player['range']**2\nWould you like to try using one of these patterns, or would you like to see more examples? We could also explore how to use this pattern to solve a specific problem you’re interested in.",
    "crumbs": [
      "2023",
      "For checking positions around the number:"
    ]
  },
  {
    "objectID": "2023/Day_1b.html",
    "href": "2023/Day_1b.html",
    "title": "Day 1b",
    "section": "",
    "text": "Your calculation isn’t quite right. It looks like some of the digits are actually spelled out with letters: one, two, three, four, five, six, seven, eight, and nine also count as valid “digits”.\nEquipped with this new information, you now need to find the real first and last digit on each line. For example:\ntwo1nine\neightwothree\nabcone2threexyz\nxtwone3four\n4nineeightseven2\nzoneight234\n7pqrstsixteen\nIn this example, the calibration values are 29, 83, 13, 24, 42, 14, and 76. Adding these together produces 281.\nWhat is the sum of all of the calibration values?\n\n\nfrom aocd import get_data\ninp = get_data(day=1, year=2023)\n\n\nxs = inp.splitlines()\n\n\nxs[:5]\n\n['five8b', '2733vmmpknvgr', '3oneeighttwo', 'twofourfive485', '2fourghsixptk']\n\n\n\nx =xs[2]\nx\n\n'3oneeighttwo'\n\n\n\n[o[index:] for index,o in enumerate(x)]\n\n['3', '', '', '', '', '', '', '', '', '', '', '']\n\n\n\n[x[index:] for index,o in enumerate(x)]\n\n['3oneeighttwo',\n 'oneeighttwo',\n 'neeighttwo',\n 'eeighttwo',\n 'eighttwo',\n 'ighttwo',\n 'ghttwo',\n 'httwo',\n 'ttwo',\n 'two',\n 'wo',\n 'o']\n\n\n\ndnames='zero,one,two,three,four,five,six,seven,eight,nine'.split(',')\ndnames\n\n['zero',\n 'one',\n 'two',\n 'three',\n 'four',\n 'five',\n 'six',\n 'seven',\n 'eight',\n 'nine']\n\n\n\na='eight234'\n[o for o in dnames if a.startswith(o)]\n\n['eight']\n\n\n\ndef dig_starts(a):\n    return [o for o in dnames if a.startswith(o)]\n\n\ndig_starts('eight234')\n\n['eight']\n\n\n\nstarts = [x[index:] for index,o in enumerate(x)]\n\n\n[dig_starts(o) for o in starts]\n\n[[], ['one'], [], [], ['eight'], [], [], [], [], ['two'], [], []]\n\n\nAI Prompt\nremind me where we are up to? where should we go next?\nAI Response\nI see you’re working on Advent of Code 2023, Day 1, part 2. You’re working with strings that contain both numeric digits and spelled-out numbers, and need to find the first and last digit (including spelled-out numbers) in each string.\nYou’ve made good progress: 1. You’ve loaded the data and can access individual strings 2. You’ve created a list of digit names 3. You’ve written a dig_starts function to check if a string starts with a digit name 4. You’re generating all possible substrings using string slicing\nThe next step would be to combine this with checking for actual digits (0-9) as well as the spelled-out numbers. Would you like help thinking through how to do that?\n\ndnames.index('eight')\n\n8\n\n\n\ndnames\n\n['zero',\n 'one',\n 'two',\n 'three',\n 'four',\n 'five',\n 'six',\n 'seven',\n 'eight',\n 'nine']\n\n\n\nfound = [dig_starts(o) for o in starts]\nfound\n\n[[], ['one'], [], [], ['eight'], [], [], [], [], ['two'], [], []]\n\n\n\nfor o in found:\n    if o: print(dnames.index(o[0]))\n\n1\n8\n2\n\n\n\nfor o in found:\n    if o: print(dnames.index(o[0]))\n\n1\n8\n2\n\n\n\na\n\n'eight234'\n\n\n\ndig_starts(a)\n\n['eight']\n\n\n\ndig_starts?\n\nSignature: dig_starts(a)\nDocstring: &lt;no docstring&gt;\nFile:      ~/&lt;ipython-input-1-57852e629243&gt;\nType:      function\n\n\n\ndig_starts??\n\nSignature: dig_starts(a)\nDocstring: &lt;no docstring&gt;\nSource:   \ndef dig_starts(a):\n    return [o for o in dnames if a.startswith(o)]\nFile:      ~/&lt;ipython-input-1-57852e629243&gt;\nType:      function\n\n\n\ndef first_dig(starts):\n    found=[dig_starts(o) for o in starts]\n    if isinstance(found,int): return found\n    for o in found:\n        if o: return dnames.index(o[0])\n\n\nfirst_dig(starts)\n\n1\n\n\n\ndef first_dig(starts):\n    found=[dig_starts(o) for o in starts]\n    \n    for o in found:\n        if isinstance(o,int): return o\n        if o: return dnames.index(o[0])\n\n\nfirst_dig(x)\n\n\ndef first_dig(x):\n    starts = [x[o:] for o,p in enumerate(x)]\n    found=[dig_starts(o) for o in starts]\n    \n    for o in found:\n        if isinstance(o,int): return o\n        if o: return dnames.index(o[0])\n\n\nfirst_dig(x)\n\n1\n\n\n\nx\n\n'3oneeighttwo'\n\n\n\nfirst_dig('eight234')\n\n8\n\n\n\nfirst_dig('eight234')\n\n8\n\n\n\nfound\n\n[[], ['one'], [], [], ['eight'], [], [], [], [], ['two'], [], []]\n\n\n\nreversed(found)\n\n&lt;list_reverseiterator at 0x708bc41a6530&gt;\n\n\n\nfor i in reversed(found):\n    print(i)\n\n[]\n[]\n['two']\n[]\n[]\n[]\n[]\n['eight']\n[]\n[]\n['one']\n[]\n\n\n\ndef get_digit(found):\n    for o in found:\n        if isinstance(o,int): return o\n        if o: return dnames.index(o[0])\n\n\ndef first_dig(x):\n    starts = [x[o:] for o,p in enumerate(x)]\n    found=[dig_starts(o) for o in starts]\n    first = get_digit(found)\n    last  = get_digit(reversed(found))\n    return first,last\n\n\ndef both_digits(x):\n    starts = [x[o:] for o,p in enumerate(x)]\n    found=[dig_starts(o) for o in starts]\n    first = get_digit(found)\n    last  = get_digit(reversed(found))\n    return first,last\n\n\ndef both_digits(x):\n    starts = [x[o:] for o,p in enumerate(x)]\n    found=[dig_starts(o) for o in starts]\n    first = get_digit(found)\n    last  = get_digit(reversed(found))\n    return first,last\n\n\nboth_digits(x)\n\n(1, 2)\n\n\n\nx\n\n'3oneeighttwo'\n\n\n\ndef both_digits(x):\n    starts = [x[o:] for o,p in enumerate(x)]\n    found=[dig_starts(o) for o in starts]\n    first = get_digit(found)\n    last  = get_digit(reversed(found))\n    return first*10+last\n\n\nget_digit??\n\nSignature: get_digit(found)\nDocstring: &lt;no docstring&gt;\nSource:   \ndef get_digit(found):\n    for o in found:\n        if isinstance(o,int): return o\n        if o: return dnames.index(o[0])\nFile:      ~/&lt;ipython-input-1-1e837a1f2a96&gt;\nType:      function",
    "crumbs": [
      "2023",
      "Day 1b"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Advent-of-Code",
    "section": "",
    "text": "This file will become your README and also the index of your documentation.",
    "crumbs": [
      "Advent-of-Code"
    ]
  },
  {
    "objectID": "index.html#developer-guide",
    "href": "index.html#developer-guide",
    "title": "Advent-of-Code",
    "section": "Developer Guide",
    "text": "Developer Guide\nIf you are new to using nbdev here are some useful pointers to get you started.\n\nInstall Advent_of_Code in Development mode\n# make sure Advent_of_Code package is installed in development mode\n$ pip install -e .\n\n# make changes under nbs/ directory\n# ...\n\n# compile to have changes apply to Advent_of_Code\n$ nbdev_prepare",
    "crumbs": [
      "Advent-of-Code"
    ]
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "Advent-of-Code",
    "section": "Usage",
    "text": "Usage\n\nInstallation\nInstall latest from the GitHub repository:\n$ pip install git+https://github.com/sky1ove/Advent-of-Code.git\nor from conda\n$ conda install -c sky1ove Advent_of_Code\nor from pypi\n$ pip install Advent_of_Code\n\n\nDocumentation\nDocumentation can be found hosted on this GitHub repository’s pages. Additionally you can find package manager specific guidelines on conda and pypi respectively.",
    "crumbs": [
      "Advent-of-Code"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "Advent-of-Code",
    "section": "How to use",
    "text": "How to use\nFill me in please! Don’t forget code examples:\n\n1+1\n\n2",
    "crumbs": [
      "Advent-of-Code"
    ]
  },
  {
    "objectID": "2023/day_1.html",
    "href": "2023/day_1.html",
    "title": "AoC day1, 2023",
    "section": "",
    "text": "samp='1abc2\npqr3stu8vwx\na1b2c3d4e5f\ntreb7uchet\n'\n\n  Cell In[1], line 1\n    samp='1abc2\n         ^\nSyntaxError: unterminated string literal (detected at line 1)\n\n\n\nAI Prompt\nhow do I fix this\nAI Response\nThe error is occurring because Python is having trouble with the multi-line string. There are two ways to fix this:\n\nUse triple quotes (““” or ’’’) for multi-line strings, or\nUse the \\n character for line breaks in a regular string\n\nHere’s option 1 with triple quotes:\nsamp = '''1abc2\npqr3stu8vwx\na1b2c3d4e5f\ntreb7uchet\n'''\nWould you like to try one of these approaches? Let me know if you need any clarification!\n\nsamp = '''1abc2\npqr3stu8vwx\na1b2c3d4e5f\ntreb7uchet\n'''\n\n\nlines = samp.splitlines() # .splitlines() can convert the \\n to list\nlines\n\n['1abc2', 'pqr3stu8vwx', 'a1b2c3d4e5f', 'treb7uchet']\n\n\n\nx=lines[1]\n\nAI Prompt\nhow do I tell if a character is a digit\nAI Response\nIn Python, you can use the isdigit() method to check if a character is a digit. For example:\n'5'.isdigit()  # Returns True\n'a'.isdigit()  # Returns False\nWould you like to try using this to check some characters in your strings? I can help you test it out!\n\nfrom aocd import get_data\ninp = get_data(day=1,year=2023)\n\n\nxs = inp.splitlines()\n\n\nx = xs[0]\n\n\n[o for o in x]\n\n['f', 'i', 'v', 'e', '8', 'b']\n\n\n\n[o for o in x if o.isdigit()]\n\n['8']\n\n\n\ndigits = [o for o in x if o.isdigit()]\n\n\ndigits[0],digits[-1]\n\n('8', '8')\n\n\n\nint(digits[0]+digits[-1])\n\n88\n\n\n\ndigits[0]+digits[-1]\n\n'88'\n\n\n\ndef get_degits(x):\n    digits = [o for o in x if o.isdigit()]\n    return sum(digits[0]+digits[-1])\n\nget_degits('abc8')\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[1], line 5\n      2     digits = [o for o in x if o.isdigit()]\n      3     return sum(digits[0]+digits[-1])\n----&gt; 5 get_degits('abc8')\n\nCell In[1], line 3, in get_degits(x)\n      1 def get_degits(x):\n      2     digits = [o for o in x if o.isdigit()]\n----&gt; 3     return sum(digits[0]+digits[-1])\n\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n\n\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\nTraceback (most recent call last):\n\n  File \"/usr/local/lib/python3.11/site-packages/IPython/core/interactiveshell.py\", line 3577, in run_code\n    exec(code_obj, self.user_global_ns, self.user_ns)\n\n  File \"&lt;ipython-input-1-6d4b20b01d58&gt;\", line 5, in &lt;module&gt;\n    get_degits('abc8')\n\n  File \"&lt;ipython-input-1-6d4b20b01d58&gt;\", line 3, in get_degits\n    return sum(digits[0]+digits[-1])\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n\n\n\ndef get_degits(x):\n    digits = [o for o in x if o.isdigit()]\n    return int(digits[0]+digits[-1])\n\nget_degits('abc8')\n\n88\n\n\n\nget_degits('abc89asdb1')\n\n81\n\n\n\nsum([get_degits(x) for x in xs])\n\n55029\n\n\nAI Prompt\nmake a dictionary that have ‘zero’:0, from 0 - 9\nAI Response\nHere’s how you can create a dictionary mapping number words to digits:\nnums = {\n    'zero': '0',\n    'one': '1',\n    'two': '2',\n    'three': '3',\n    'four': '4',\n    'five': '5',\n    'six': '6',\n    'seven': '7',\n    'eight': '8',\n    'nine': '9'\n}\nWould you like to test it out? Let me know what you’d like to do with it!\n\nnums = {\n    'zero': '0',\n    'one': '1',\n    'two': '2',\n    'three': '3',\n    'four': '4',\n    'five': '5',\n    'six': '6',\n    'seven': '7',\n    'eight': '8',\n    'nine': '9'\n}\n\nmake a function have convert strings to number if they have those in nums\nAI Prompt\nmake a function have convert strings to number if they have those in nums\nAI Response\nLet’s break this down. Do you want to find and convert number words (like ‘one’, ‘two’) within a string into their digit equivalents?\nBefore I suggest an approach, could you give me an example of what you want the function to do? For instance, what should happen with a string like “onetwothree” or “hello2one”?\nThis will help me guide you toward the most appropriate solution.\n\nhello2one would be hello21\n\n  Cell In[1], line 1\n    hello2one would be hello21\n              ^\nSyntaxError: invalid syntax\n\n\n\nAI Prompt\nhello2one would be hello21\nAI Response\nAh, I understand now - you want to keep the digits and replace any number words with their corresponding digits.\nLet’s think about how to solve this step by step: 1. First, we’ll need to find any number words in the string 2. Then replace them with their corresponding digits 3. Keep any existing digits unchanged\nWould you like to try writing this function, or would you like me to suggest some code to get started?\nAI Prompt\nyes, suggest some code\nAI Response\nHere’s a starting point using string replacement:\ndef convert_numbers(s):\n    result = s\n    for word, digit in nums.items():\n        result = result.replace(word, digit)\n    return result\nTry this out and let me know if it works for your needs! We can test it with some examples like: - “hello2one” - “twothree”\nWould you like to try it?\n\ndef convert_numbers(strings):\n    for world, digit in nums.items():\n        strings = strings.replace(word,digit)\n    return strings\n\nconvert_numbers('hello1two')\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[1], line 6\n      3         strings = strings.replace(word,digit)\n      4     return strings\n----&gt; 6 convert_numbers('hello1two')\n\nCell In[1], line 3, in convert_numbers(strings)\n      1 def convert_numbers(strings):\n      2     for world, digit in nums.items():\n----&gt; 3         strings = strings.replace(word,digit)\n      4     return strings\n\nNameError: name 'word' is not defined\n\n\nNameError: name 'word' is not defined\nTraceback (most recent call last):\n\n  File \"/usr/local/lib/python3.11/site-packages/IPython/core/interactiveshell.py\", line 3577, in run_code\n    exec(code_obj, self.user_global_ns, self.user_ns)\n\n  File \"&lt;ipython-input-1-e8ad9b5fe513&gt;\", line 6, in &lt;module&gt;\n    convert_numbers('hello1two')\n\n  File \"&lt;ipython-input-1-e8ad9b5fe513&gt;\", line 3, in convert_numbers\n    strings = strings.replace(word,digit)\n                              ^^^^\n\nNameError: name 'word' is not defined\n\n\n\ndef convert_numbers(strings):\n    for word, digit in nums.items():\n        strings = strings.replace(word,digit)\n    return strings\n\nconvert_numbers('hello1two')\n\n'hello12'\n\n\n\nxs_converted = [convert_numbers(o) for o in xs]\n\n\nxs_converted[0]\n\n'58b'\n\n\n\nxs[0]\n\n'five8b'\n\n\n\ndef get_degits(x):\n    digits = [o for o in x if o.isdigit()]\n    return int(digits[0]+digits[-1])\n\nget_degits('abc8')\n\n88\n\n\n\ndef get_digits(x):\n    digits = [o for o in x if o.isdigit()]\n    return int(digits[0]+digits[-1])\n\nget_digits('abc8')\n\n88\n\n\n\nxs_digits = [get_digits(o) for o in xs_converted]\n\n\nxs_digits[0]\n\n58\n\n\n\nsum(xs_digits)\n\n55194\n\n\nAI Prompt\nfor nums dictionary, could you also covers something like sixteen, basically all of the digits\nAI Response\nThe nums dictionary currently only covers zero through nine, since those are the basic digit words. Numbers like “sixteen” are compound numbers (made up of “six” and “teen”) and aren’t typically converted to single digits.\nIf you want to handle numbers like “sixteen”, we should first clarify: 1. What range of numbers do you want to cover? 2. What digit should “sixteen” convert to - should it be ‘1’ and ‘6’, or something else?\nLet me know what you’re trying to achieve and I can help you expand the dictionary appropriately!\nAI Prompt\nsixteen would be like 16, yes I’d like to have a dictionary of compound numbers\nAI Response\nI can help you create an expanded dictionary that includes compound numbers. Here’s a suggestion - should we add:\n\nNumbers 11-19 (eleven through nineteen)\nMultiples of 10 up to 90 (twenty, thirty, etc.)\nOr would you like to go up to a specific number?\n\nLet me know which range you’d like to cover and I can help you create the appropriate dictionary!\nAI Prompt\nyes, 1-2\nAI Response\nI’ll help you create an expanded dictionary that includes numbers 11-19 and the multiples of 10 up to 90. Here’s the addition to your existing dictionary:\nnums.update({\n    'eleven': '11',\n    'twelve': '12',\n    'thirteen': '13',\n    'fourteen': '14',\n    'fifteen': '15',\n    'sixteen': '16',\n    'seventeen': '17',\n    'eighteen': '18',\n    'nineteen': '19',\n    'twenty': '20',\n    'thirty': '30',\n    'forty': '40',\n    'fifty': '50',\n    'sixty': '60',\n    'seventy': '70',\n    'eighty': '80',\n    'ninety': '90'\n})\nWould you like to try this out and see if it works with your existing code?\n\nnums.update({\n    'eleven': '11',\n    'twelve': '12',\n    'thirteen': '13',\n    'fourteen': '14',\n    'fifteen': '15',\n    'sixteen': '16',\n    'seventeen': '17',\n    'eighteen': '18',\n    'nineteen': '19',\n    'twenty': '20',\n    'thirty': '30',\n    'forty': '40',\n    'fifty': '50',\n    'sixty': '60',\n    'seventy': '70',\n    'eighty': '80',\n    'ninety': '90'\n})\n\n\nnums\n\n{'zero': '0',\n 'one': '1',\n 'two': '2',\n 'three': '3',\n 'four': '4',\n 'five': '5',\n 'six': '6',\n 'seven': '7',\n 'eight': '8',\n 'nine': '9',\n 'eleven': '11',\n 'twelve': '12',\n 'thirteen': '13',\n 'fourteen': '14',\n 'fifteen': '15',\n 'sixteen': '16',\n 'seventeen': '17',\n 'eighteen': '18',\n 'nineteen': '19',\n 'twenty': '20',\n 'thirty': '30',\n 'forty': '40',\n 'fifty': '50',\n 'sixty': '60',\n 'seventy': '70',\n 'eighty': '80',\n 'ninety': '90'}\n\n\n\nsum([get_digits(convert_numbers(o)) for o in xs])\n\n55194\n\n\n\n'5'.isdigit()\n\nTrue\n\n\n\n'5sdf'.isdigit()\n\nFalse\n\n\n\n's'.isdigit()\n\nFalse\n\n\n\n's'.isalpha??\n\nObject `isalpha` not found.\n\n\n\n's'.isalpha()\n\nTrue\n\n\n\n's'.isalnum()\n\nTrue\n\n\n\n's'.istitle()\n\nFalse\n\n\n\n'Ssss'.istitle()\n\nTrue",
    "crumbs": [
      "2023",
      "AoC day1, 2023"
    ]
  },
  {
    "objectID": "2023/Day_5.html",
    "href": "2023/Day_5.html",
    "title": "Advent-of-Code",
    "section": "",
    "text": "pip install 'advent-of-code-data[nb]'\n\nCollecting advent-of-code-data[nb]\n  Downloading advent_of_code_data-2.0.4-py3-none-any.whl.metadata (11 kB)\nRequirement already satisfied: beautifulsoup4 in /usr/local/lib/python3.10/dist-packages (from advent-of-code-data[nb]) (4.12.3)\nCollecting pebble (from advent-of-code-data[nb])\n  Downloading Pebble-5.1.0-py3-none-any.whl.metadata (3.6 kB)\nRequirement already satisfied: urllib3 in /usr/local/lib/python3.10/dist-packages (from advent-of-code-data[nb]) (2.2.3)\nCollecting aocd-example-parser&gt;=2023.2 (from advent-of-code-data[nb])\n  Downloading aocd_example_parser-2023.12.20-py3-none-any.whl.metadata (8.9 kB)\nRequirement already satisfied: IPython in /usr/local/lib/python3.10/dist-packages (from advent-of-code-data[nb]) (7.34.0)\nRequirement already satisfied: jupyter-server in /usr/local/lib/python3.10/dist-packages (from advent-of-code-data[nb]) (1.24.0)\nRequirement already satisfied: soupsieve&gt;1.2 in /usr/local/lib/python3.10/dist-packages (from beautifulsoup4-&gt;advent-of-code-data[nb]) (2.6)\nRequirement already satisfied: setuptools&gt;=18.5 in /usr/local/lib/python3.10/dist-packages (from IPython-&gt;advent-of-code-data[nb]) (75.1.0)\nCollecting jedi&gt;=0.16 (from IPython-&gt;advent-of-code-data[nb])\n  Downloading jedi-0.19.2-py2.py3-none-any.whl.metadata (22 kB)\nRequirement already satisfied: decorator in /usr/local/lib/python3.10/dist-packages (from IPython-&gt;advent-of-code-data[nb]) (4.4.2)\nRequirement already satisfied: pickleshare in /usr/local/lib/python3.10/dist-packages (from IPython-&gt;advent-of-code-data[nb]) (0.7.5)\nRequirement already satisfied: traitlets&gt;=4.2 in /usr/local/lib/python3.10/dist-packages (from IPython-&gt;advent-of-code-data[nb]) (5.7.1)\nRequirement already satisfied: prompt-toolkit!=3.0.0,!=3.0.1,&lt;3.1.0,&gt;=2.0.0 in /usr/local/lib/python3.10/dist-packages (from IPython-&gt;advent-of-code-data[nb]) (3.0.48)\nRequirement already satisfied: pygments in /usr/local/lib/python3.10/dist-packages (from IPython-&gt;advent-of-code-data[nb]) (2.18.0)\nRequirement already satisfied: backcall in /usr/local/lib/python3.10/dist-packages (from IPython-&gt;advent-of-code-data[nb]) (0.2.0)\nRequirement already satisfied: matplotlib-inline in /usr/local/lib/python3.10/dist-packages (from IPython-&gt;advent-of-code-data[nb]) (0.1.7)\nRequirement already satisfied: pexpect&gt;4.3 in /usr/local/lib/python3.10/dist-packages (from IPython-&gt;advent-of-code-data[nb]) (4.9.0)\nRequirement already satisfied: anyio&lt;4,&gt;=3.1.0 in /usr/local/lib/python3.10/dist-packages (from jupyter-server-&gt;advent-of-code-data[nb]) (3.7.1)\nRequirement already satisfied: argon2-cffi in /usr/local/lib/python3.10/dist-packages (from jupyter-server-&gt;advent-of-code-data[nb]) (23.1.0)\nRequirement already satisfied: jinja2 in /usr/local/lib/python3.10/dist-packages (from jupyter-server-&gt;advent-of-code-data[nb]) (3.1.4)\nRequirement already satisfied: jupyter-client&gt;=6.1.12 in /usr/local/lib/python3.10/dist-packages (from jupyter-server-&gt;advent-of-code-data[nb]) (6.1.12)\nRequirement already satisfied: jupyter-core!=5.0.*,&gt;=4.12 in /usr/local/lib/python3.10/dist-packages (from jupyter-server-&gt;advent-of-code-data[nb]) (5.7.2)\nRequirement already satisfied: nbconvert&gt;=6.4.4 in /usr/local/lib/python3.10/dist-packages (from jupyter-server-&gt;advent-of-code-data[nb]) (7.16.4)\nRequirement already satisfied: nbformat&gt;=5.2.0 in /usr/local/lib/python3.10/dist-packages (from jupyter-server-&gt;advent-of-code-data[nb]) (5.10.4)\nRequirement already satisfied: packaging in /usr/local/lib/python3.10/dist-packages (from jupyter-server-&gt;advent-of-code-data[nb]) (24.2)\nRequirement already satisfied: prometheus-client in /usr/local/lib/python3.10/dist-packages (from jupyter-server-&gt;advent-of-code-data[nb]) (0.21.1)\nRequirement already satisfied: pyzmq&gt;=17 in /usr/local/lib/python3.10/dist-packages (from jupyter-server-&gt;advent-of-code-data[nb]) (24.0.1)\nRequirement already satisfied: Send2Trash in /usr/local/lib/python3.10/dist-packages (from jupyter-server-&gt;advent-of-code-data[nb]) (1.8.3)\nRequirement already satisfied: terminado&gt;=0.8.3 in /usr/local/lib/python3.10/dist-packages (from jupyter-server-&gt;advent-of-code-data[nb]) (0.18.1)\nRequirement already satisfied: tornado&gt;=6.1.0 in /usr/local/lib/python3.10/dist-packages (from jupyter-server-&gt;advent-of-code-data[nb]) (6.3.3)\nRequirement already satisfied: websocket-client in /usr/local/lib/python3.10/dist-packages (from jupyter-server-&gt;advent-of-code-data[nb]) (1.8.0)\nRequirement already satisfied: idna&gt;=2.8 in /usr/local/lib/python3.10/dist-packages (from anyio&lt;4,&gt;=3.1.0-&gt;jupyter-server-&gt;advent-of-code-data[nb]) (3.10)\nRequirement already satisfied: sniffio&gt;=1.1 in /usr/local/lib/python3.10/dist-packages (from anyio&lt;4,&gt;=3.1.0-&gt;jupyter-server-&gt;advent-of-code-data[nb]) (1.3.1)\nRequirement already satisfied: exceptiongroup in /usr/local/lib/python3.10/dist-packages (from anyio&lt;4,&gt;=3.1.0-&gt;jupyter-server-&gt;advent-of-code-data[nb]) (1.2.2)\nRequirement already satisfied: parso&lt;0.9.0,&gt;=0.8.4 in /usr/local/lib/python3.10/dist-packages (from jedi&gt;=0.16-&gt;IPython-&gt;advent-of-code-data[nb]) (0.8.4)\nRequirement already satisfied: python-dateutil&gt;=2.1 in /usr/local/lib/python3.10/dist-packages (from jupyter-client&gt;=6.1.12-&gt;jupyter-server-&gt;advent-of-code-data[nb]) (2.8.2)\nRequirement already satisfied: platformdirs&gt;=2.5 in /usr/local/lib/python3.10/dist-packages (from jupyter-core!=5.0.*,&gt;=4.12-&gt;jupyter-server-&gt;advent-of-code-data[nb]) (4.3.6)\nRequirement already satisfied: bleach!=5.0.0 in /usr/local/lib/python3.10/dist-packages (from nbconvert&gt;=6.4.4-&gt;jupyter-server-&gt;advent-of-code-data[nb]) (6.2.0)\nRequirement already satisfied: defusedxml in /usr/local/lib/python3.10/dist-packages (from nbconvert&gt;=6.4.4-&gt;jupyter-server-&gt;advent-of-code-data[nb]) (0.7.1)\nRequirement already satisfied: jupyterlab-pygments in /usr/local/lib/python3.10/dist-packages (from nbconvert&gt;=6.4.4-&gt;jupyter-server-&gt;advent-of-code-data[nb]) (0.3.0)\nRequirement already satisfied: markupsafe&gt;=2.0 in /usr/local/lib/python3.10/dist-packages (from nbconvert&gt;=6.4.4-&gt;jupyter-server-&gt;advent-of-code-data[nb]) (3.0.2)\nRequirement already satisfied: mistune&lt;4,&gt;=2.0.3 in /usr/local/lib/python3.10/dist-packages (from nbconvert&gt;=6.4.4-&gt;jupyter-server-&gt;advent-of-code-data[nb]) (3.0.2)\nRequirement already satisfied: nbclient&gt;=0.5.0 in /usr/local/lib/python3.10/dist-packages (from nbconvert&gt;=6.4.4-&gt;jupyter-server-&gt;advent-of-code-data[nb]) (0.10.1)\nRequirement already satisfied: pandocfilters&gt;=1.4.1 in /usr/local/lib/python3.10/dist-packages (from nbconvert&gt;=6.4.4-&gt;jupyter-server-&gt;advent-of-code-data[nb]) (1.5.1)\nRequirement already satisfied: tinycss2 in /usr/local/lib/python3.10/dist-packages (from nbconvert&gt;=6.4.4-&gt;jupyter-server-&gt;advent-of-code-data[nb]) (1.4.0)\nRequirement already satisfied: fastjsonschema&gt;=2.15 in /usr/local/lib/python3.10/dist-packages (from nbformat&gt;=5.2.0-&gt;jupyter-server-&gt;advent-of-code-data[nb]) (2.21.1)\nRequirement already satisfied: jsonschema&gt;=2.6 in /usr/local/lib/python3.10/dist-packages (from nbformat&gt;=5.2.0-&gt;jupyter-server-&gt;advent-of-code-data[nb]) (4.23.0)\nRequirement already satisfied: ptyprocess&gt;=0.5 in /usr/local/lib/python3.10/dist-packages (from pexpect&gt;4.3-&gt;IPython-&gt;advent-of-code-data[nb]) (0.7.0)\nRequirement already satisfied: wcwidth in /usr/local/lib/python3.10/dist-packages (from prompt-toolkit!=3.0.0,!=3.0.1,&lt;3.1.0,&gt;=2.0.0-&gt;IPython-&gt;advent-of-code-data[nb]) (0.2.13)\nRequirement already satisfied: argon2-cffi-bindings in /usr/local/lib/python3.10/dist-packages (from argon2-cffi-&gt;jupyter-server-&gt;advent-of-code-data[nb]) (21.2.0)\nRequirement already satisfied: webencodings in /usr/local/lib/python3.10/dist-packages (from bleach!=5.0.0-&gt;nbconvert&gt;=6.4.4-&gt;jupyter-server-&gt;advent-of-code-data[nb]) (0.5.1)\nRequirement already satisfied: attrs&gt;=22.2.0 in /usr/local/lib/python3.10/dist-packages (from jsonschema&gt;=2.6-&gt;nbformat&gt;=5.2.0-&gt;jupyter-server-&gt;advent-of-code-data[nb]) (24.2.0)\nRequirement already satisfied: jsonschema-specifications&gt;=2023.03.6 in /usr/local/lib/python3.10/dist-packages (from jsonschema&gt;=2.6-&gt;nbformat&gt;=5.2.0-&gt;jupyter-server-&gt;advent-of-code-data[nb]) (2024.10.1)\nRequirement already satisfied: referencing&gt;=0.28.4 in /usr/local/lib/python3.10/dist-packages (from jsonschema&gt;=2.6-&gt;nbformat&gt;=5.2.0-&gt;jupyter-server-&gt;advent-of-code-data[nb]) (0.35.1)\nRequirement already satisfied: rpds-py&gt;=0.7.1 in /usr/local/lib/python3.10/dist-packages (from jsonschema&gt;=2.6-&gt;nbformat&gt;=5.2.0-&gt;jupyter-server-&gt;advent-of-code-data[nb]) (0.22.3)\nRequirement already satisfied: six&gt;=1.5 in /usr/local/lib/python3.10/dist-packages (from python-dateutil&gt;=2.1-&gt;jupyter-client&gt;=6.1.12-&gt;jupyter-server-&gt;advent-of-code-data[nb]) (1.17.0)\nRequirement already satisfied: cffi&gt;=1.0.1 in /usr/local/lib/python3.10/dist-packages (from argon2-cffi-bindings-&gt;argon2-cffi-&gt;jupyter-server-&gt;advent-of-code-data[nb]) (1.17.1)\nRequirement already satisfied: pycparser in /usr/local/lib/python3.10/dist-packages (from cffi&gt;=1.0.1-&gt;argon2-cffi-bindings-&gt;argon2-cffi-&gt;jupyter-server-&gt;advent-of-code-data[nb]) (2.22)\nDownloading aocd_example_parser-2023.12.20-py3-none-any.whl (12 kB)\nDownloading advent_of_code_data-2.0.4-py3-none-any.whl (38 kB)\nDownloading Pebble-5.1.0-py3-none-any.whl (36 kB)\nDownloading jedi-0.19.2-py2.py3-none-any.whl (1.6 MB)\n   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 1.6/1.6 MB 20.8 MB/s eta 0:00:00\nInstalling collected packages: pebble, jedi, aocd-example-parser, advent-of-code-data\nSuccessfully installed advent-of-code-data-2.0.4 aocd-example-parser-2023.12.20 jedi-0.19.2 pebble-5.1.0\n\n\n\n\nimport os\nos.environ['AOC_SESSION'] = \"53616c7465645f5ffc51b1b4030426e2eb3ee5d5406f6e51f3a56c32ca9649e34ee45d8d8faceeb1d781fc4d6352b3ba2c0d868e7c2de79192d8ebb9787d1eca\"\n\n\nfrom aocd import get_data\nfrom dataclasses import dataclass\n\n\ndata = get_data(day=5,year=2024)\n\n\nfrom dataclasses import dataclass\n\n@dataclass\nclass MyClass:\n    src: int\n    length: int\n\n    def get_range(self):\n        \"\"\"Get the range as (start, end).\"\"\"\n        return self.src, self.src + self.length\n\n    def cut_to_overlap(self, reference):\n        \"\"\"Cut this object to fit within the reference object's range.\"\"\"\n        ref_start, ref_end = reference.get_range()\n        obj_start, obj_end = self.get_range()\n\n        # Calculate the overlapping range\n        overlap_start = max(ref_start, obj_start)\n        overlap_end = min(ref_end, obj_end)\n\n        # If there's no overlap, return None\n        if overlap_start &gt;= overlap_end:\n            return None\n\n        # Create a new object with the overlapping range\n        return MyClass(overlap_start, overlap_end - overlap_start)\n\n\ndef get_uncovered_parts(reference_obj, other_objects):\n    \"\"\"Get the parts of the reference object not covered by other objects.\"\"\"\n    ref_start, ref_end = reference_obj.get_range()\n    uncovered_parts = []\n\n    # Start with the entire reference range\n    current_ranges = [(ref_start, ref_end)]\n\n    # Process all overlapping objects to subtract their ranges from the reference range\n    for obj in other_objects:\n        obj_start, obj_end = obj.get_range()\n        new_ranges = []\n        for start, end in current_ranges:\n            # No overlap, keep the current range\n            if obj_end &lt;= start or obj_start &gt;= end:\n                new_ranges.append((start, end))\n            else:\n                # If overlapping, split into uncovered ranges\n                if obj_start &gt; start:\n                    new_ranges.append((start, obj_start))\n                if obj_end &lt; end:\n                    new_ranges.append((obj_end, end))\n        current_ranges = new_ranges\n\n    # Convert the remaining ranges into MyClass objects\n    for start, end in current_ranges:\n        uncovered_parts.append(MyClass(start, end - start))\n\n    return uncovered_parts\n\n\n# Example usage\nreference = MyClass(10, 20)  # Reference object: src=10, length=20\nother_objects = [\n    MyClass(5, 10),   # Partially overlaps\n    MyClass(20, 10),  # Overlaps fully within the reference\n    MyClass(30, 10)   # Does not overlap\n]\n\n# Get the uncovered parts of the reference object\nuncovered_parts = get_uncovered_parts(reference, other_objects)\n\nuncovered_parts\n\n[MyClass(src=15, length=5)]\n\n\n\noverlapping\n\n[MyClass(src=10, length=5),\n MyClass(src=15, length=10),\n MyClass(src=25, length=5)]\n\n\n\noverlapping[0].get_range()\n\n(10, 15)\n\n\n\nfrom dataclasses import dataclass\n\n@dataclass\nclass MyClass:\n    src: int\n    dest: int\n    length: int\n\n    def get_range(self):\n        \"\"\"Get the range as (start, end) in the src context.\"\"\"\n        return self.src, self.src + self.length\n\n    def cut_to_overlap(self, reference):\n        \"\"\"Cut this object to fit within the reference object's range.\"\"\"\n        ref_start, ref_end = reference.get_range()\n        obj_start, obj_end = self.get_range()\n\n        # Calculate the overlapping range\n        overlap_start = max(ref_start, obj_start)\n        overlap_end = min(ref_end, obj_end)\n\n        # If there's no overlap, return None\n        if overlap_start &gt;= overlap_end:\n            return None\n\n        # Calculate the corresponding dest range for the overlap\n        overlap_length = overlap_end - overlap_start\n        dest_overlap_start = self.dest + (overlap_start - obj_start)\n\n        # Create a new object with the overlapping range in the dest context\n        return MyClass(overlap_start, dest_overlap_start, overlap_length)\n\n\ndef get_uncovered_parts(reference_obj, other_objects):\n    \"\"\"Get the parts of the reference object not covered by other objects.\"\"\"\n    ref_start, ref_end = reference_obj.get_range()\n    uncovered_parts = []\n\n    # Start with the entire reference range\n    current_ranges = [(ref_start, ref_end)]\n\n    # Process all overlapping objects to subtract their ranges from the reference range\n    for obj in other_objects:\n        obj_start, obj_end = obj.get_range()\n        new_ranges = []\n        for start, end in current_ranges:\n            # No overlap, keep the current range\n            if obj_end &lt;= start or obj_start &gt;= end:\n                new_ranges.append((start, end))\n            else:\n                # If overlapping, split into uncovered ranges\n                if obj_start &gt; start:\n                    new_ranges.append((start, obj_start))\n                if obj_end &lt; end:\n                    new_ranges.append((obj_end, end))\n        current_ranges = new_ranges\n\n    # Convert the remaining ranges into MyClass objects (in src context only)\n    for start, end in current_ranges:\n        uncovered_parts.append(MyClass(start, None, end - start))\n\n    return uncovered_parts\n\n\ndef separate_and_convert_to_dest(reference_obj, other_objects):\n    \"\"\"Get the overlapping parts in the dest context.\"\"\"\n    overlapping_dest_objects = []\n\n    for obj in other_objects:\n        cut_obj = obj.cut_to_overlap(reference_obj)\n        if cut_obj:\n            overlapping_dest_objects.append(cut_obj)\n\n    return overlapping_dest_objects\n\n\n# Example usage\nreference = MyClass(10, 0, 20)  # Reference object: src=10, dest=0, length=20\nother_objects = [\n    MyClass(5, 100, 10),   # Partially overlaps\n    MyClass(20, 200, 10),  # Overlaps fully\n    MyClass(25, 300, 10),  # Does not overlap\n]\n\n# Get the overlapping parts converted to dest context\noverlapping_dest_objects = separate_and_convert_to_dest(reference, other_objects)\n\n# Get the uncovered parts in src context\nuncovered_parts = get_uncovered_parts(reference, other_objects)\n\n\noverlapping_dest_objects\n\n[MyClass(src=10, dest=105, length=5),\n MyClass(src=20, dest=200, length=10),\n MyClass(src=25, dest=300, length=5)]\n\n\n\nuncovered_parts\n\n[MyClass(src=15, dest=None, length=5)]\n\n\n\nfrom fastcore.utils import L\n\n\nlines = L([[50, 98, 2], [52, 50, 48]],[[0, 15, 37], [37, 52, 2], [39, 0, 15]],[[49, 53, 8], [0, 11, 42], [42, 0, 7], [57, 7, 4]],[[88, 18, 7], [18, 25, 70]],[[45, 77, 23], [81, 45, 19], [68, 64, 13]],[[0, 69, 1], [1, 0, 69]],[[60, 56, 37], [56, 93, 4]])\n\n\nobject_lines = lines.map(lambda x: L(x).starmap(lambda dest,src,length: MyClass(src,dest,length)))\nobject_lines\n\n(#7) [[MyClass(src=98, dest=50, length=2), MyClass(src=50, dest=52, length=48)],[MyClass(src=15, dest=0, length=37), MyClass(src=52, dest=37, length=2), MyClass(src=0, dest=39, length=15)],[MyClass(src=53, dest=49, length=8), MyClass(src=11, dest=0, length=42), MyClass(src=0, dest=42, length=7), MyClass(src=7, dest=57, length=4)],[MyClass(src=18, dest=88, length=7), MyClass(src=25, dest=18, length=70)],[MyClass(src=77, dest=45, length=23), MyClass(src=45, dest=81, length=19), MyClass(src=64, dest=68, length=13)],[MyClass(src=69, dest=0, length=1), MyClass(src=0, dest=1, length=69)],[MyClass(src=56, dest=60, length=37), MyClass(src=93, dest=56, length=4)]]\n\n\n\nseed = [79,14,55,13]\n\n\ndef convert_for_next_round(objects):\n    \"\"\"\n    Convert objects for the next round by updating src to dest,\n    and clearing dest (if dest is None, src remains unchanged).\n    \"\"\"\n    converted_objects = []\n    for obj in objects:\n        new_src = obj.dest if obj.dest is not None else obj.src\n        converted_objects.append(MyClass(src=new_src, dest=None, length=obj.length))\n    return converted_objects\n\ndef process_round(current_objects, new_objects):\n    \"\"\"\n    Process a single round of comparison, including overlap and uncovered calculations.\n    \"\"\"\n    # Treat the current objects as the reference for this round\n    reference_objects = current_objects\n\n    # Find overlapping parts in the dest context\n    merged_results = []\n    for ref_obj in reference_objects:\n        ref_overlapping = separate_and_convert_to_dest(ref_obj, new_objects)\n        ref_uncovered = get_uncovered_parts(ref_obj, new_objects)\n\n        # Merge overlapping and uncovered parts for this reference object\n        merged_results.extend(ref_overlapping + ref_uncovered)\n\n    return merged_results\n\n\n\n# Combine overlapping and uncovered objects for conversion\nconverted_objects = convert_for_next_round(overlapping_dest_objects + uncovered_parts)\n\n# New objects for the next round\nnew_objects_next_round = [\n    MyClass(100, 400, 10),\n    MyClass(110, 410, 10),\n    MyClass(120, 420, 10),\n]\n\n# Process the next round\nout = process_round(converted_objects, new_objects_next_round)\n\n\nout\n\n[MyClass(src=105, dest=405, length=5),\n MyClass(src=200, dest=None, length=10),\n MyClass(src=300, dest=None, length=5),\n MyClass(src=15, dest=None, length=5)]\n\n\n\ndef process_all_rounds(rounds, references):\n    \"\"\"\n    Process all rounds of conversion with multiple references.\n\n    Args:\n        rounds: List of lists of MyClass objects (7 rounds of objects).\n        references: List of MyClass reference objects.\n\n    Returns:\n        Dictionary: Overlapping objects for each reference (keyed by their src values).\n    \"\"\"\n    results = {}  # Dynamically store results for each reference\n\n    for i, round_objects in enumerate(rounds):\n        print(f\"Processing Round {i + 1}...\")\n\n        # Process each reference independently\n        new_references = []\n        for ref in references:\n            # Ensure the reference's src is in results\n            if ref.src not in results:\n                results[ref.src] = []\n\n            overlapping, uncovered = process_round([ref], round_objects)\n\n            # Append overlapping objects to results for this reference\n            results[ref.src].extend(overlapping)\n\n            # Update references for the next round\n            # Convert overlapping objects for next round (src = dest)\n            converted_overlapping = convert_for_next_round(overlapping)\n            new_references.extend(converted_overlapping)\n\n            # Keep uncovered parts as they are\n            new_references.extend(uncovered)\n\n        # Update references for the next round\n        references = new_references\n\n    return results\n\n\ndef process_all_rounds(rounds, references):\n    \"\"\"\n    Process all rounds of conversion with multiple references.\n\n    Args:\n        rounds: List of lists of MyClass objects (7 rounds of objects).\n        references: List of MyClass reference objects.\n\n    Returns:\n        Dictionary: Overlapping objects for each reference (keyed by their src values).\n    \"\"\"\n    results = {}  # Dynamically store results for each reference\n\n    for i, round_objects in enumerate(rounds):\n        print(f\"Processing Round {i + 1}...\")\n\n        # Process each reference independently\n        new_references = []\n        for ref in references:\n            print(ref,'aa')\n            # Ensure the reference's src is in results\n            if ref.src not in results:\n                results[ref.src] = []\n\n            # Process the round and get merged results (both overlapping and uncovered)\n            merged_results = process_round([ref], round_objects)\n\n            # Append all results to the corresponding reference's results\n            results[ref.src].extend(merged_results)\n\n            # Convert all merged results for the next round\n            converted_results = convert_for_next_round(merged_results)\n            new_references.extend(converted_results)\n\n        # Update references for the next round with all converted results\n        references = new_references\n\n    return min([o.src for o in references])\n\n\ndef process_all_rounds(rounds, references):\n    \"\"\"\n    Process all rounds of conversion with multiple references and return the minimum src value.\n\n    Args:\n        rounds: List of lists of MyClass objects (7 rounds of objects).\n        references: List of MyClass reference objects.\n\n    Returns:\n        int: Minimum src value from the final references after all rounds.\n    \"\"\"\n    for i, round_objects in enumerate(rounds):\n        # print(f\"Processing Round {i + 1}...\")\n\n        # Process each reference independently\n        new_references = []\n        for ref in references:\n            # print(ref)\n\n            # Process the round and get merged results (both overlapping and uncovered)\n            merged_results = process_round([ref], round_objects)\n\n            # Convert all merged results for the next round\n            converted_results = convert_for_next_round(merged_results)\n            new_references.extend(converted_results)\n\n        # Update references for the next round with all converted results\n        references = new_references\n\n    # Return the minimum src value from the final references\n    return min([o.src for o in references])\n\n\n# Example input\n\nrounds = [\n    [MyClass(src=98, dest=50, length=2), MyClass(src=50, dest=52, length=48)],\n    [MyClass(src=15, dest=0, length=37), MyClass(src=52, dest=37, length=2), MyClass(src=0, dest=39, length=15)],\n    [MyClass(src=53, dest=49, length=8), MyClass(src=11, dest=0, length=42), MyClass(src=0, dest=42, length=7), MyClass(src=7, dest=57, length=4)],\n    [MyClass(src=18, dest=88, length=7), MyClass(src=25, dest=18, length=70)],\n    [MyClass(src=77, dest=45, length=23), MyClass(src=45, dest=81, length=19), MyClass(src=64, dest=68, length=13)],\n    [MyClass(src=69, dest=0, length=1), MyClass(src=0, dest=1, length=69)],\n    [MyClass(src=56, dest=60, length=37), MyClass(src=93, dest=56, length=4)],\n]\n\n\n# Two reference inputs\nreferences = [\n    MyClass(src=79, dest=None, length=14),\n    MyClass(src=55, dest=None, length=13),\n]\n\n# Process all rounds\nresults = process_all_rounds(rounds, references)\nresults\n\n46\n\n\n\ndef process_input(samp):\n    seeds,*lines = samp.split('\\n\\n')\n    seeds = L(seeds.strip().split(':')[1].split()).map(int)\n    return seeds, linesb\n\n\ndata =get_data(day=5,year=2023)\n\n\nseeds, lines = process_input(data)\n\n\ndef process(line): return L(line.split(':')[1].strip().split('\\n')).map(lambda x: L(x.split()).map(int))\n_lines = L(lines).map(process)\n\n\nobject_lines = _lines.map(lambda x: L(x).starmap(lambda dest,src,length: MyClass(src,dest,length)))\nrounds = object_lines\n\n\nseeds\n\n(#20) [222541566,218404460,670428364,432472902,2728902838,12147727,3962570697,52031641,2849288350,113747257,3648852659,73423293,4036058422,190602154,1931540843,584314999,3344622241,180428346,1301166628,310966761]\n\n\n\nseeds[::2]\n\n(#10) [222541566,670428364,2728902838,3962570697,2849288350,3648852659,4036058422,1931540843,3344622241,1301166628]\n\n\n\nreferences = [\n    MyClass(src=src, dest=None, length=length)\n    for src, length in zip(seeds[::2], seeds[1::2])\n]\n\n\n# Process all rounds\nresults = process_all_rounds(rounds, references)\nresults\n\n27992443",
    "crumbs": [
      "2023",
      "Day_5.html"
    ]
  },
  {
    "objectID": "2023/Day_4.html",
    "href": "2023/Day_4.html",
    "title": "AOC Day4",
    "section": "",
    "text": "As far as the Elf has been able to figure out, you have to figure out which of the numbers you have appear in the list of winning numbers. The first match makes the card worth one point and each match after the first doubles the point value of that card.\nFor example:\nIn the above example, card 1 has five winning numbers (41, 48, 83, 86, and 17) and eight numbers you have (83, 86, 6, 31, 17, 9, 48, and 53). Of the numbers you have, four of them (48, 83, 17, and 86) are winning numbers! That means card 1 is worth 8 points (1 for the first match, then doubled three times for each of the three matches after the first).\nCard 2 has two winning numbers (32 and 61), so it is worth 2 points. Card 3 has two winning numbers (1 and 21), so it is worth 2 points. Card 4 has one winning number (84), so it is worth 1 point. Card 5 has no winning numbers, so it is worth no points. Card 6 has no winning numbers, so it is worth no points. So, in this example, the Elf’s pile of scratchcards is worth 13 points.\nfrom aocd import get_data\nfrom fastcore.utils import L\ninp = get_data(year=2023,day=4)\nsamp = '''\nCard 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53\nCard 2: 13 32 20 16 61 | 61 30 68 82 17 32 24 19\nCard 3:  1 21 53 59 44 | 69 82 63 72 16 21 14  1\nCard 4: 41 92 73 84 69 | 59 84 76 51 58  5 54 83\nCard 5: 87 83 26 28 32 | 88 30 70 12 93 22 82 36\nCard 6: 31 18 13 56 72 | 74 77 10 23 35 67 36 11\n'''\ndef process_inp(inp): return L(inp.strip().splitlines())\nx =process_inp(samp)\nx\n\n(#6) ['Card 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53','Card 2: 13 32 20 16 61 | 61 30 68 82 17 32 24 19','Card 3:  1 21 53 59 44 | 69 82 63 72 16 21 14  1','Card 4: 41 92 73 84 69 | 59 84 76 51 58  5 54 83','Card 5: 87 83 26 28 32 | 88 30 70 12 93 22 82 36','Card 6: 31 18 13 56 72 | 74 77 10 23 35 67 36 11']\nline = x[0]\nline\n\n'Card 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53'\ndef get_win_true(line):\n    line = line.split(':')[1]\n    return line.split('|')[0].split(), line.split('|')[1].split()\nwin,true = get_win_true(line)\nwin,true\n\n(['41', '48', '83', '86', '17'],\n ['83', '86', '6', '31', '17', '9', '48', '53'])\n'41' in win\n\nTrue\ndef in_win(x,win_list): return x in win_list\nL(true).map(in_win,win_list=win)\n\n(#8) [True,True,False,False,True,False,True,False]\nL(true).map(in_win,win_list=win).sum()\n\n4\ndef get_win_len(true,win): return L(true).map(in_win,win_list=win).sum()\nnum_len = get_win_len(true,win)\nnum_len\n\n4\ndef calculate_power(num_len): return 2**(num_len-1) if num_len else None\ncalculate_power(0)\ncalculate_power(num_len)\n\n8\ndef line2num(line):\n    win,true = get_win_true(line)\n    num_len = get_win_len(true,win)\n    return calculate_power(num_len)\nline2num(line)\n\n8\nx\n\n(#6) ['Card 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53','Card 2: 13 32 20 16 61 | 61 30 68 82 17 32 24 19','Card 3:  1 21 53 59 44 | 69 82 63 72 16 21 14  1','Card 4: 41 92 73 84 69 | 59 84 76 51 58  5 54 83','Card 5: 87 83 26 28 32 | 88 30 70 12 93 22 82 36','Card 6: 31 18 13 56 72 | 74 77 10 23 35 67 36 11']\nx.map(line2num).filter().sum()\n\n13\nx_full = process_inp(inp)\nx_full.map(line2num).filter().sum()\n\n23750",
    "crumbs": [
      "2023",
      "AOC Day4"
    ]
  },
  {
    "objectID": "2023/Day_4.html#part-b",
    "href": "2023/Day_4.html#part-b",
    "title": "AOC Day4",
    "section": "Part b",
    "text": "Part b\nCopies of scratchcards are scored like normal scratchcards and have the same card number as the card they copied. So, if you win a copy of card 10 and it has 5 matching numbers, it would then win a copy of the same cards that the original card 10 won: cards 11, 12, 13, 14, and 15. This process repeats until none of the copies cause you to win any more cards. (Cards will never make you copy a card past the end of the table.)\nThis time, the above example goes differently:\nCard 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53\nCard 2: 13 32 20 16 61 | 61 30 68 82 17 32 24 19\nCard 3:  1 21 53 59 44 | 69 82 63 72 16 21 14  1\nCard 4: 41 92 73 84 69 | 59 84 76 51 58  5 54 83\nCard 5: 87 83 26 28 32 | 88 30 70 12 93 22 82 36\nCard 6: 31 18 13 56 72 | 74 77 10 23 35 67 36 11\nCard 1 has four matching numbers, so you win one copy each of the next four cards: cards 2, 3, 4, and 5. Your original card 2 has two matching numbers, so you win one copy each of cards 3 and 4. Your copy of card 2 also wins one copy each of cards 3 and 4. Your four instances of card 3 (one original and three copies) have two matching numbers, so you win four copies each of cards 4 and 5. Your eight instances of card 4 (one original and seven copies) have one matching number, so you win eight copies of card 5. Your fourteen instances of card 5 (one original and thirteen copies) have no matching numbers and win no more cards. Your one instance of card 6 (one original) has no matching numbers and wins no more cards.\n\nget_win_true(line)\n\n(['41', '48', '83', '86', '17'],\n ['83', '86', '6', '31', '17', '9', '48', '53'])\n\n\n\nget_win_len(true,win)\n\n4\n\n\n\ndef line2len(line):\n    win,true = get_win_true(line)\n    return get_win_len(true,win)\n\nMake a dictionary of all of card, with card number as key, and card copies ad value\n\ndef get_card_len(x): return L((i,line2len(line)) for i,line in enumerate(x,start=1))\ncard_len = get_card_len(x)\ncard_len\n\n(#6) [(1, 4),(2, 2),(3, 2),(4, 1),(5, 0),(6, 0)]\n\n\n\nk,v = card_len[0]\nk,v\n\n(1, 4)\n\n\nmake a dictionary of k as card number, and value as copy number; initiate the dictionary at copy number =1\n\ndef init_dict(x): return {i:1 for i in range(1,len(x)+1)}\ncard_copy_dict = init_dict(x)\ncard_copy_dict\n\n{1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}\n\n\ndefine a function that add number to the dictionary\n\ndef add_copy(k,v):\n    # print([k+i for i in range(1,v+1)])\n    added_value = card_copy_dict[k]\n    for i in range(1,v+1):\n        card_copy_dict[k+i]+=added_value\nadd_copy(k,v),card_copy_dict\n\n(None, {1: 1, 2: 3, 3: 3, 4: 3, 5: 3, 6: 2})\n\n\n\ncard_copy_dict = init_dict(x)\ncard_copy_dict\n\n{1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}\n\n\n\ndef process(x):\n    global card_copy_dict\n    card_copy_dict = init_dict(x)\n    print(card_copy_dict)\n    card_len = get_card_len(x)\n    card_len.starmap(add_copy)\n    \n    print(card_copy_dict)\n    return sum(card_copy_dict.values())\nprocess(x)\n\n{1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}\n{1: 1, 2: 2, 3: 4, 4: 8, 5: 14, 6: 1}\n\n\n30\n\n\n\nprocess(x_full)\n\n{1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1, 15: 1, 16: 1, 17: 1, 18: 1, 19: 1, 20: 1, 21: 1, 22: 1, 23: 1, 24: 1, 25: 1, 26: 1, 27: 1, 28: 1, 29: 1, 30: 1, 31: 1, 32: 1, 33: 1, 34: 1, 35: 1, 36: 1, 37: 1, 38: 1, 39: 1, 40: 1, 41: 1, 42: 1, 43: 1, 44: 1, 45: 1, 46: 1, 47: 1, 48: 1, 49: 1, 50: 1, 51: 1, 52: 1, 53: 1, 54: 1, 55: 1, 56: 1, 57: 1, 58: 1, 59: 1, 60: 1, 61: 1, 62: 1, 63: 1, 64: 1, 65: 1, 66: 1, 67: 1, 68: 1, 69: 1, 70: 1, 71: 1, 72: 1, 73: 1, 74: 1, 75: 1, 76: 1, 77: 1, 78: 1, 79: 1, 80: 1, 81: 1, 82: 1, 83: 1, 84: 1, 85: 1, 86: 1, 87: 1, 88: 1, 89: 1, 90: 1, 91: 1, 92: 1, 93: 1, 94: 1, 95: 1, 96: 1, 97: 1, 98: 1, 99: 1, 100: 1, 101: 1, 102: 1, 103: 1, 104: 1, 105: 1, 106: 1, 107: 1, 108: 1, 109: 1, 110: 1, 111: 1, 112: 1, 113: 1, 114: 1, 115: 1, 116: 1, 117: 1, 118: 1, 119: 1, 120: 1, 121: 1, 122: 1, 123: 1, 124: 1, 125: 1, 126: 1, 127: 1, 128: 1, 129: 1, 130: 1, 131: 1, 132: 1, 133: 1, 134: 1, 135: 1, 136: 1, 137: 1, 138: 1, 139: 1, 140: 1, 141: 1, 142: 1, 143: 1, 144: 1, 145: 1, 146: 1, 147: 1, 148: 1, 149: 1, 150: 1, 151: 1, 152: 1, 153: 1, 154: 1, 155: 1, 156: 1, 157: 1, 158: 1, 159: 1, 160: 1, 161: 1, 162: 1, 163: 1, 164: 1, 165: 1, 166: 1, 167: 1, 168: 1, 169: 1, 170: 1, 171: 1, 172: 1, 173: 1, 174: 1, 175: 1, 176: 1, 177: 1, 178: 1, 179: 1, 180: 1, 181: 1, 182: 1, 183: 1, 184: 1, 185: 1, 186: 1, 187: 1, 188: 1, 189: 1, 190: 1, 191: 1, 192: 1, 193: 1, 194: 1, 195: 1, 196: 1, 197: 1, 198: 1, 199: 1, 200: 1, 201: 1, 202: 1, 203: 1, 204: 1, 205: 1, 206: 1, 207: 1, 208: 1, 209: 1, 210: 1, 211: 1, 212: 1, 213: 1, 214: 1}\n{1: 1, 2: 2, 3: 4, 4: 8, 5: 16, 6: 32, 7: 64, 8: 94, 9: 188, 10: 176, 11: 352, 12: 639, 13: 1278, 14: 2188, 15: 4376, 16: 8752, 17: 16132, 18: 32088, 19: 48860, 20: 80949, 21: 1, 22: 2, 23: 3, 24: 6, 25: 12, 26: 24, 27: 48, 28: 94, 29: 164, 30: 328, 31: 328, 32: 222, 33: 441, 34: 271, 35: 542, 36: 271, 37: 1, 38: 2, 39: 4, 40: 8, 41: 16, 42: 32, 43: 64, 44: 128, 45: 256, 46: 510, 47: 972, 48: 1943, 49: 3886, 50: 7258, 51: 7250, 52: 12429, 53: 24858, 54: 49652, 55: 99304, 56: 148700, 57: 284971, 58: 420270, 59: 840540, 60: 551683, 61: 7251, 62: 1, 63: 2, 64: 4, 65: 8, 66: 16, 67: 32, 68: 32, 69: 64, 70: 128, 71: 188, 72: 188, 73: 375, 74: 748, 75: 1496, 76: 2984, 77: 5952, 78: 2968, 79: 5904, 80: 11620, 81: 20868, 82: 41736, 83: 71852, 84: 119493, 85: 238986, 86: 400216, 87: 1, 88: 2, 89: 4, 90: 8, 91: 14, 92: 28, 93: 56, 94: 112, 95: 224, 96: 448, 97: 896, 98: 1679, 99: 3358, 100: 6480, 101: 12064, 102: 24086, 103: 48116, 104: 96232, 105: 185984, 106: 185536, 107: 346986, 108: 678550, 109: 1355421, 110: 1936060, 111: 1403538, 112: 1, 113: 2, 114: 4, 115: 8, 116: 16, 117: 32, 118: 64, 119: 126, 120: 252, 121: 488, 122: 912, 123: 1335, 124: 2670, 125: 5304, 126: 10600, 127: 13226, 128: 24991, 129: 49070, 130: 1, 131: 2, 132: 4, 133: 8, 134: 16, 135: 31, 136: 62, 137: 120, 138: 104, 139: 206, 140: 350, 141: 311, 142: 518, 143: 1036, 144: 1761, 145: 1, 146: 1, 147: 2, 148: 4, 149: 8, 150: 16, 151: 32, 152: 56, 153: 110, 154: 220, 155: 440, 156: 880, 157: 1755, 158: 3478, 159: 6956, 160: 12157, 161: 24188, 162: 44898, 163: 77363, 164: 154726, 165: 302496, 166: 458103, 167: 612830, 168: 612830, 169: 1, 170: 1, 171: 2, 172: 4, 173: 8, 174: 8, 175: 16, 176: 28, 177: 54, 178: 108, 179: 216, 180: 431, 181: 862, 182: 1670, 183: 3340, 184: 1670, 185: 3316, 186: 6524, 187: 6496, 188: 12992, 189: 22668, 190: 45120, 191: 83313, 192: 165764, 193: 203095, 194: 391528, 195: 1, 196: 2, 197: 4, 198: 8, 199: 16, 200: 30, 201: 60, 202: 120, 203: 224, 204: 444, 205: 887, 206: 1270, 207: 383, 208: 766, 209: 1524, 210: 917, 211: 1804, 212: 1684, 213: 1684, 214: 918}\n\n\n13261850",
    "crumbs": [
      "2023",
      "AOC Day4"
    ]
  }
]