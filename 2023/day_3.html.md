# For checking positions around the number:


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

## Day3

The engine schematic (your puzzle input) consists of a visual
representation of the engine. There are lots of numbers and symbols you
don’t really understand, but apparently any number adjacent to a symbol,
even diagonally, is a “part number” and should be included in your sum.
(Periods (.) do not count as a symbol.)

Here is an example engine schematic:

    467..114..
    ...*......
    ..35..633.
    ......#...
    617*......
    .....+.58.
    ..592.....
    ......755.
    ...$.*....
    .664.598..

In this schematic, two numbers are not part numbers because they are not
adjacent to a symbol: 114 (top right) and 58 (middle right). Every other
number is adjacent to a symbol and so is a part number; their sum is
4361.

Of course, the actual engine schematic is much larger. What is the sum
of all of the part numbers in the engine schematic?

``` python
sample = '''
467..114..
...*......
..35..633.
......#...
617*......
.....+.58.
..592.....
......755.
...$.*....
.664.598..
'''
```

``` python
nums = [467,114,35,633,617,58,592,755,664,598]
```

``` python
nums.remove(114)
```

``` python
nums.remove(58)
```

``` python
nums
```

    [467, 35, 633, 617, 592, 755, 664, 598]

``` python
sum(nums)
```

    4361

**AI Prompt**

what’s next?

**AI Response**

I notice you’ve worked through the example and successfully calculated
the sum of part numbers (4361) after removing the non-part numbers (114
and 58).

Now we need to solve this for the actual puzzle input. Would you like
to: 1. Load and parse the actual input file, or 2. First work on
creating a function that can automatically detect which numbers are part
numbers (adjacent to symbols)?

Which would you prefer to tackle first?

**AI Prompt**

2

**AI Response**

OK, let’s work on creating a function to detect part numbers. Let’s
break this down into steps:

1.  First, we need to identify what counts as a symbol (anything except
    digits and periods)
2.  Then, we need to check all 8 adjacent positions around each digit of
    a number
3.  If any of those positions contains a symbol, the entire number is a
    part number

Would you like to start by writing a function to identify symbols? We
could create a simple helper function that returns True if a character
is a symbol.

Would you like to try writing this function first?

``` python
a = '.....+.58.'
```

``` python
[o for o in a if a.isdigit()]
```

    []

``` python
[o for o in a]
```

    ['.', '.', '.', '.', '.', '+', '.', '5', '8', '.']

``` python
for o in a:
    print(a.isdigit())
```

    False
    False
    False
    False
    False
    False
    False
    False
    False
    False

``` python
for o in a:
    print(a.isnumeric())
```

    False
    False
    False
    False
    False
    False
    False
    False
    False
    False

**AI Prompt**

how to know if it is a symbol

**AI Response**

I notice you’re trying to check digits, but you’re using `a.isdigit()`
which checks the whole string. Let’s check each character individually.

To identify a symbol, we need something that is: - Not a digit (0-9) -
Not a period (.)

Here’s a way to test one character:

``` python
def is_symbol(char):
    return not (char.isdigit() or char == '.')
```

Would you like to try this function on some sample characters to see if
it works?

``` python
[o for o in a if o.isdigit()]
```

    ['5', '8']

``` python
[o for o in a if not o.isdigit()]
```

    ['.', '.', '.', '.', '.', '+', '.', '.']

``` python
[o for o in a if not o.isdigit() or o!='.']
```

    ['.', '.', '.', '.', '.', '+', '.', '5', '8', '.']

``` python
[o for o in a if not o.isdigit() or o=='.']
```

    ['.', '.', '.', '.', '.', '+', '.', '.']

``` python
[o for o in a if o!='.']
```

    ['+', '5', '8']

``` python
[o for o in a if not o.isdigit() and o!='.']
```

    ['+']

``` python
def is_symbol(char):
    return not (char.isdigit() or char == '.')
```

``` python
is_symbol(a)
```

    True

``` python
for o in a:
    print(o)
    print(is_symbol(o))
```

    .
    False
    .
    False
    .
    False
    .
    False
    .
    False
    +
    True
    .
    False
    5
    False
    8
    False
    .
    False

**AI Prompt**

what’s next?

**AI Response**

Great! You’ve successfully created and tested the is_symbol function.
Now we need to:

1.  Check all 8 positions around a number for symbols (up, down, left,
    right, and all diagonals)
2.  First though, we need to convert our input into a format where we
    can easily access positions. A 2D list/grid might work well here.

Would you like to try converting the sample input into a 2D grid first?
We can use the sample string we had earlier and split it into rows.

Would you like to try this, or would you like some hints on how to do
it?

**AI Prompt**

give me some hints on how to do it

**AI Response**

Here are some hints for converting the input into a 2D grid:

1.  First, look at the sample string - notice it has newlines () between
    rows
2.  You can use `.strip()` to remove any extra whitespace/newlines at
    the start/end
3.  Then `.split('\n')` will give you a list of rows
4.  Each row is a string that you can treat like a list of characters

Would you like to try using these hints to create the grid from our
sample input? We can test it with a small print statement to make sure
it looks right.

``` python
sample
```

    '\n467..114..\n...*......\n..35..633.\n......#...\n617*......\n.....+.58.\n..592.....\n......755.\n...$.*....\n.664.598..\n'

``` python
sample
```

    '\n467..114..\n...*......\n..35..633.\n......#...\n617*......\n.....+.58.\n..592.....\n......755.\n...$.*....\n.664.598..\n'

``` python
sample.strip()
```

    '467..114..\n...*......\n..35..633.\n......#...\n617*......\n.....+.58.\n..592.....\n......755.\n...$.*....\n.664.598..'

``` python
sample.strip().splitlines()
```

    ['467..114..',
     '...*......',
     '..35..633.',
     '......#...',
     '617*......',
     '.....+.58.',
     '..592.....',
     '......755.',
     '...$.*....',
     '.664.598..']

``` python
def preprocess_raw(inp):
    return inp.strip().splitlines()
```

``` python
preprocess_raw(sample)
```

    ['467..114..',
     '...*......',
     '..35..633.',
     '......#...',
     '617*......',
     '.....+.58.',
     '..592.....',
     '......755.',
     '...$.*....',
     '.664.598..']

**AI Prompt**

what’s next?

**AI Response**

Great! You’ve got the grid structure set up. Now we need to find numbers
and check if they’re adjacent to symbols.

For each number, we’ll need to: 1. Find where it starts and ends in a
row 2. Check all positions around those digits for symbols (including
diagonals)

Would you like to start by writing code to find the numbers in a row? We
could write a function that takes a row string and returns the positions
of all numbers in it.

Would you like to try this, or would you like some hints?

``` python
def get_row_digit_position(row):
    indexes=[]
    for char in row:
        if char.isdigit():
            indexes.append(row.index(char))
```

``` python
get_row_digit_position('.2....456')
```

``` python
def get_row_digit_position(row):
    indexes=[]
    for char in row:
        if char.isdigit():
            indexes.append(row.index(char))
    return indexes
```

``` python
get_row_digit_position('.2....456')
```

    [1, 6, 7, 8]

**AI Prompt**

what’s next?

**AI Response**

I notice that your function has a small issue - using `row.index(char)`
will always give you the first occurrence of a digit in the string. For
example, if you had ‘..22..’, both 2’s would show the same position.

Let’s modify the function to track the actual position as we go through
the string. Would you like to try this approach: 1. Use `enumerate()` to
get both the character and its position 2. Store both the position and
the digit when we find one

Would you like to try modifying your function, or would you like some
hints?

``` python
def get_row_digit_position(row):
    indexes=[]
    for index, char in enumerate(row):
        if char.isdigit():
            indexes.append(index)
    return indexes
```

``` python
get_row_digit_position('..22..')
```

    [2, 3]

**AI Prompt**

modified, what’s next?

**AI Response**

Great! Now we need to identify complete numbers, not just individual
digits. For example, in ‘..22..’ we want to know that there’s one number
(22) at positions 2-3, not two separate digits.

We need to look for consecutive digits and group them together. When we
find a digit, we should: 1. Check if it’s connected to the previous
digit 2. If yes, add it to that number 3. If no, start a new number

Would you like to try modifying your function to group consecutive
digits, or would you like some hints on how to do this?

**AI Prompt**

give me a hint to modify the function

**AI Response**

Here’s a hint: You can detect if digits are part of the same number by
checking if their positions are consecutive.

For example, if you have the indexes \[2,3,6,7,8\]: - 2 and 3 are
consecutive (difference of 1) so they’re one number - Then there’s a
gap - 6,7,8 are consecutive so they’re another number

You might want to: 1. Keep track of the start position of the current
number 2. When you find a gap (difference \> 1), that means the previous
number is complete 3. Store both the start and end positions of each
complete number

Would you like to try implementing this, or would you like more specific
hints?

**AI Prompt**

should I write a separate function or modify the existing
get_row_digit_position

**AI Response**

I’d recommend writing a new function that uses get_row_digit_position as
a helper function. This follows good programming practice of having each
function do one specific thing:

1.  `get_row_digit_position` finds individual digit positions
2.  New function will group these positions into complete numbers

This way, each function is simpler and easier to test. Would you like to
try writing this new function, or would you like some hints on how to
structure it?

**AI Prompt**

how to find a gap(different \>1) in a list of numbers

**AI Response**

There are a few ways to find gaps in a list of numbers. Here’s one
approach:

You can compare each number with the next number in the list using a
loop. For example, with indexes \[2,3,6,7,8\]: 1. Compare 2 with 3: 3-2
= 1 (no gap) 2. Compare 3 with 6: 6-3 = 3 (gap found!) 3. Compare 6 with
7: 7-6 = 1 (no gap) 4. Compare 7 with 8: 8-7 = 1 (no gap)

You can use `zip()` with slicing to look at pairs of numbers:

``` python
numbers = [2,3,6,7,8]
for curr, next_num in zip(numbers, numbers[1:]):
    if next_num - curr > 1:
        print(f"Found gap between {curr} and {next_num}")
```

Would you like to try using this approach in your function?

``` python
numbers = [2,3,6,7,8]
for curr, next_num in zip(numbers, numbers[1:]):
    if next_num - curr > 1:
        print(f"Found gap between {curr} and {next_num}")
```

    Found gap between 3 and 6

**AI Prompt**

or use regex to extract number from row?

**AI Response**

Yes, using regex is another good approach! It might actually be simpler
since regex can directly find consecutive digits. Here’s a hint for
using regex:

1.  You’ll want to use `re.finditer()` which will give you both the
    numbers and their positions
2.  The pattern `\d+` will match one or more consecutive digits
3.  Each match object will give you both:
    - The number (match.group())
    - Its position (match.start() and match.end())

Would you like to try writing a function using regex, or would you like
to see an example pattern first?

``` python
import re
```

``` python
re.finditer?
```

    Signature: re.finditer(pattern, string, flags=0)
    Docstring:
    Return an iterator over all non-overlapping matches in the
    string.  For each match, the iterator returns a Match object.

    Empty matches are included in the result.
    File:      /usr/local/lib/python3.11/re/__init__.py
    Type:      function

``` python
re.finditer('\d+','...23..1')
```

    <callable_iterator at 0x708bbd7e3070>

``` python
[o for o in re.finditer('\d+','...23..1')]
```

    [<re.Match object; span=(3, 5), match='23'>,
     <re.Match object; span=(7, 8), match='1'>]

**AI Prompt**

how to use regex to find number?

**AI Response**

Let’s break this down. From your test, we can see that `re.finditer()`
returns match objects. Here’s how to extract the useful information from
each match:

``` python
test_str = '...23..1'
for match in re.finditer('\d+', test_str):
    number = int(match.group())  # the actual number
    start = match.start()        # starting position
    end = match.end()           # ending position
    print(f"Found number {number} at positions {start}-{end}")
```

Would you like to try this out and then turn it into a function that
returns this information in a useful format?

``` python
test_str = '...23..1'
for match in re.finditer('\d+', test_str):
    number = int(match.group())  # the actual number
    start = match.start()        # starting position
    end = match.end()           # ending position
    print(f"Found number {number} at positions {start}-{end}")
```

    Found number 23 at positions 3-5
    Found number 1 at positions 7-8

**AI Prompt**

which return format is good?

**AI Response**

For this puzzle, we’ll need both the numbers and their positions to
check for adjacent symbols. Here are some possible return formats:

1.  List of tuples: `[(number, start, end), ...]`

    ``` python
    [(23, 3, 5), (1, 7, 8)]
    ```

2.  List of dictionaries: `[{'number': n, 'start': s, 'end': e}, ...]`

    ``` python
    [{'number': 23, 'start': 3, 'end': 5}, {'number': 1, 'start': 7, 'end': 8}]
    ```

The tuple format is more concise, while the dictionary format is more
readable.

Which format would you prefer to work with?

``` python
def get_num_position(row):

    for match in re.finditer('\d+', row):
        number = int(match.group())  # the actual number
        start = match.start()        # starting position
        end = match.end()           # ending position
    return dict(number=number,start=start,end=end)
```

``` python
get_num_position('..2..33')
```

    {'number': 33, 'start': 5, 'end': 7}

``` python
def get_num_position(row):
    dicts = []
    for match in re.finditer('\d+', row):
        number = int(match.group())  # the actual number
        start = match.start()        # starting position
        end = match.end()           # ending position
        dicts.append(dict(number=number,start=start,end=end))
    return dicts
```

``` python
get_num_position('..2..33')
```

    [{'number': 2, 'start': 2, 'end': 3}, {'number': 33, 'start': 5, 'end': 7}]

**AI Prompt**

what’s next?

**AI Response**

Great! Now that we can find numbers and their positions in a row, we
need to:

1.  Check if each number is adjacent to any symbols (including
    diagonally)
2.  For this, we’ll need to look at:
    - The row above (if it exists)
    - The same row
    - The row below (if it exists)

Would you like to write a function that checks if a number is adjacent
to any symbols? We can use our existing `is_symbol` function to help
with this.

Would you like to try this, or would you like some hints on how to check
the adjacent positions?

``` python
is_symbol?
```

    Signature: is_symbol(char)
    Docstring: <no docstring>
    File:      ~/<ipython-input-1-f7baa4904f7b>
    Type:      function

``` python
is_symbol??
```

    Signature: is_symbol(char)
    Docstring: <no docstring>
    Source:   
    def is_symbol(char):
        return not (char.isdigit() or char == '.')
    File:      ~/<ipython-input-1-f7baa4904f7b>
    Type:      function

**AI Prompt**

give me hints on how to check the adjacent positions?

**AI Response**

Here’s how we can think about checking adjacent positions:

For a number that starts at position `start` and ends at position `end`,
we need to check:

1.  One position before start and one position after end in the same row
2.  For the row above and below, check all positions from:
    - (start-1) to (end+1)

For example, if we have “..23.” and 23 is at positions 2-3:

    Check positions:
    Row above: 1,2,3,4
    Same row: 1,4
    Row below: 1,2,3,4

Would you like to try writing a function that takes: - The current row -
The row above (if any) - The row below (if any) - The start and end
positions of a number

And returns whether any adjacent position contains a symbol?

``` python
sample
```

    '\n467..114..\n...*......\n..35..633.\n......#...\n617*......\n.....+.58.\n..592.....\n......755.\n...$.*....\n.664.598..\n'

``` python
xs = preprocess_raw(sample)
```

``` python
xs
```

    ['467..114..',
     '...*......',
     '..35..633.',
     '......#...',
     '617*......',
     '.....+.58.',
     '..592.....',
     '......755.',
     '...$.*....',
     '.664.598..']

``` python
xs[0][1]
```

    '6'

``` python
dict_one = {'number': 33, 'start': 5, 'end': 7}
index = 1
```

**AI Prompt**

give me a hint on how to check adajacent?

``` python
row_start = dict_one['start'] - 1    # one position before number
row_end = dict_one['end'] + 1      # one position after number
```

``` python
xs[index-1][row_start:row_end+1],xs[index][row_start],xs[index][row_end], xs[index+1][row_start:row_end+1]
```

    ('.114.', '.', '.', '..633')

``` python
xs[0][5:20]
```

    '114..'

``` python
xs[0][-5:2]
```

    ''

``` python
xs[0]
```

    '467..114..'

``` python
xs[0][-1:5]
```

    ''

**AI Prompt**

how to make it become a function?

**AI Response**

Let’s create a function that checks for adjacent symbols. Here’s a
suggested structure:

``` python
def has_adjacent_symbol(grid, row_idx, number_dict):
    """
    grid: list of rows (xs in your case)
    row_idx: which row the number is in
    number_dict: dictionary with 'start' and 'end' positions
    """
    row_start = max(0, number_dict['start'] - 1)  # don't go below 0
    row_end = min(len(grid[0]), number_dict['end'] + 1)  # don't go past end
    
    # Check above row if it exists
    if row_idx > 0:
        above = grid[row_idx-1][row_start:row_end+1]
        # check for symbols in above
        
    # Check current row (just the ends)
    current = grid[row_idx][row_start], grid[row_idx][row_end]
    
    # Check below row if it exists
    if row_idx < len(grid)-1:
        below = grid[row_idx+1][row_start:row_end+1]
        # check for symbols in below

    return # True if any symbols found
```

Would you like to try completing this function? I can help with any
specific part you’re unsure about.

``` python
def has_adjacent_symbol(grid, row_idx, number_dict):
    """
    grid: list of rows
    row_idx: which row the number is in
    number_dict: dictionary with 'start' and 'end' positions
    """
    row_start = max(0, number_dict['start'] - 1)  # don't go below 0
    row_end = min(len(grid[0]), number_dict['end'] + 1)  # don't go past end
    
    # Check above row if it exists
    if row_idx > 0:
        above = grid[row_idx-1][row_start:row_end+1]
        # check for symbols in above
        
    # Check current row (just the ends)
    current = grid[row_idx][row_start], grid[row_idx][row_end]
    
    # Check below row if it exists
    if row_idx < len(grid)-1:
        below = grid[row_idx+1][row_start:row_end+1]
        # check for symbols in below

    return above,current,below
```

``` python
dict_one
```

    {'number': 33, 'start': 5, 'end': 7}

``` python
row = xs[1]
```

``` python
get_row_digit_position(row)
```

    []

``` python
# get_row_digit_position
```

``` python
get_row_digit_position?
```

    Signature: get_row_digit_position(row)
    Docstring: <no docstring>
    File:      ~/<ipython-input-1-c808883576b3>
    Type:      function

``` python
get_row_digit_position??
```

    Signature: get_row_digit_position(row)
    Docstring: <no docstring>
    Source:   
    def get_row_digit_position(row):
        indexes=[]
        for index, char in enumerate(row):
            if char.isdigit():
                indexes.append(index)
        return indexes
    File:      ~/<ipython-input-1-c808883576b3>
    Type:      function

``` python
row
```

    '...*......'

``` python
row = xs[2]
row
```

    '..35..633.'

``` python
get_row_digit_position(row)
```

    [2, 3, 6, 7, 8]

``` python
get_num_position??
```

    Signature: get_num_position(row)
    Docstring: <no docstring>
    Source:   
    def get_num_position(row):
        dicts = []
        for match in re.finditer('\d+', row):
            number = int(match.group())  # the actual number
            start = match.start()        # starting position
            end = match.end()           # ending position
            dicts.append(dict(number=number,start=start,end=end))
        return dicts
    File:      ~/<ipython-input-1-b591f7575837>
    Type:      function

``` python
get_num_position(row)
```

    [{'number': 35, 'start': 2, 'end': 4}, {'number': 633, 'start': 6, 'end': 9}]

``` python
row_dicts = get_num_position(row)
```

``` python
dict_one = row_dicts[0]
```

``` python
row_index=2
```

``` python
has_adjacent_symbol?
```

    Signature: has_adjacent_symbol(grid, row_idx, number_dict)
    Docstring:
    grid: list of rows
    row_idx: which row the number is in
    number_dict: dictionary with 'start' and 'end' positions
    File:      ~/<ipython-input-1-8f0094edfba7>
    Type:      function

``` python
has_adjacent_symbol(xs,2,dict_one)
```

    ('..*..', ('.', '.'), '.....')

``` python
is_symbol??
```

    Signature: is_symbol(char)
    Docstring: <no docstring>
    Source:   
    def is_symbol(char):
        return not (char.isdigit() or char == '.')
    File:      ~/<ipython-input-1-f7baa4904f7b>
    Type:      function

``` python
def check_symbol(strings):
    for char in strings:
        if not (char.isdigit() or char == '.'):
            return True
    return False
```

``` python
check_symbol('..*..')
```

    True

``` python
check_symbol(('.', '.'))
```

    False

``` python
for i in ('.', '.'): print(i)
```

    .
    .

**AI Prompt**

is `check_symbol` good?

**AI Response**

Yes, `check_symbol` looks good! It: 1. Takes either a string or an
iterable of characters 2. Returns True if any character is a symbol (not
a digit and not a period) 3. Returns False if no symbols are found

Now we can modify our `has_adjacent_symbol` function to use
`check_symbol` on: - The above row - The current row ends - The below
row

Would you like to try updating the `has_adjacent_symbol` function to use
`check_symbol`?

**AI Prompt**

help me update

**AI Response**

Here’s how we can update the function step by step:

``` python
def has_adjacent_symbol(grid, row_idx, number_dict):
    row_start = max(0, number_dict['start'] - 1)  # don't go below 0
    row_end = min(len(grid[0]), number_dict['end'] + 1)  # don't go past end
    
    # Check above row if it exists
    if row_idx > 0:
        above = grid[row_idx-1][row_start:row_end+1]
        if check_symbol(above):
            return True
    
    # Check current row (just the ends)
    current = grid[row_idx][row_start], grid[row_idx][row_end]
    if check_symbol(current):
        return True
    
    # Check below row if it exists
    if row_idx < len(grid)-1:
        below = grid[row_idx+1][row_start:row_end+1]
        if check_symbol(below):
            return True
            
    return False
```

Would you like to try this out with your example to see if it correctly
identifies numbers adjacent to symbols?

``` python
def has_adjacent_symbol(grid, row_idx, number_dict):
    row_start = max(0, number_dict['start'] - 1)  # don't go below 0
    row_end = min(len(grid[0]), number_dict['end'] + 1)  # don't go past end
    
    # Check above row if it exists
    if row_idx > 0:
        above = grid[row_idx-1][row_start:row_end+1]
        if check_symbol(above):
            return True
    
    # Check current row (just the ends)
    current = grid[row_idx][row_start], grid[row_idx][row_end]
    if check_symbol(current):
        return True
    
    # Check below row if it exists
    if row_idx < len(grid)-1:
        below = grid[row_idx+1][row_start:row_end+1]
        if check_symbol(below):
            return True
            
    return False
```

``` python
has_adjacent_symbol(xs,2,dict_one)
```

    True

**AI Prompt**

what’s next?

**AI Response**

Great! Now that we have all the pieces working: 1. `get_num_position` to
find numbers in a row 2. `has_adjacent_symbol` to check if a number is
adjacent to symbols

We need to: 1. Loop through each row in the grid 2. Find all numbers in
that row 3. Check each number for adjacent symbols 4. Sum up the numbers
that have adjacent symbols

Would you like to try writing this main logic, or would you like some
hints on how to structure it?

``` python
get_num_position??
```

    Signature: get_num_position(row)
    Docstring: <no docstring>
    Source:   
    def get_num_position(row):
        dicts = []
        for match in re.finditer('\d+', row):
            number = int(match.group())  # the actual number
            start = match.start()        # starting position
            end = match.end()           # ending position
            dicts.append(dict(number=number,start=start,end=end))
        return dicts
    File:      ~/<ipython-input-1-b591f7575837>
    Type:      function

``` python
nums=[]
for row in xs:
    row_dicts = get_num_position(row)
    for row_dict in row_dicts:
        if has_adjacent_symbol(xs,2,dict_one):
            nums.append(row_dict['number'])

nums
```

    [467, 114, 35, 633, 617, 58, 592, 755, 664, 598]

``` python
nums=[]
for row_index, row in enumerate(xs):
    row_dicts = get_num_position(row)
    for row_dict in row_dicts:
        if has_adjacent_symbol(xs,row_index,row_dict):
            nums.append(row_dict['number'])

nums
```

    ---------------------------------------------------------------------------
    IndexError                                Traceback (most recent call last)
    Cell In[1], line 5
          3     row_dicts = get_num_position(row)
          4     for row_dict in row_dicts:
    ----> 5         if has_adjacent_symbol(xs,row_index,row_dict):
          6             nums.append(row_dict['number'])
          8 nums

    Cell In[1], line 12, in has_adjacent_symbol(grid, row_idx, number_dict)
          9         return True
         11 # Check current row (just the ends)
    ---> 12 current = grid[row_idx][row_start], grid[row_idx][row_end]
         13 if check_symbol(current):
         14     return True

    IndexError: string index out of range

    IndexError: string index out of range
    Traceback (most recent call last):

      File "/usr/local/lib/python3.11/site-packages/IPython/core/interactiveshell.py", line 3577, in run_code
        exec(code_obj, self.user_global_ns, self.user_ns)

      File "<ipython-input-1-a428d73095ab>", line 5, in <module>
        if has_adjacent_symbol(xs,row_index,row_dict):
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

      File "<ipython-input-1-0382fd1e3b43>", line 12, in has_adjacent_symbol
        current = grid[row_idx][row_start], grid[row_idx][row_end]
                                            ~~~~~~~~~~~~~^^^^^^^^^

    IndexError: string index out of range

**AI Prompt**

got this error

**AI Response**

Ah, we have an index out of range error. This happens because we’re
trying to access a position beyond the end of the string. Let’s fix the
`has_adjacent_symbol` function:

1.  We need to be more careful with the end position check
2.  We should only check positions that exist in the string

Here’s how we can modify the function:

``` python
def has_adjacent_symbol(grid, row_idx, number_dict):
    row_length = len(grid[0])
    row_start = max(0, number_dict['start'] - 1)  # don't go below 0
    row_end = min(row_length - 1, number_dict['end'])  # don't go past last index
    
    # Check above row if it exists
    if row_idx > 0:
        above = grid[row_idx-1][row_start:row_end+1]
        if check_symbol(above):
            return True
    
    # Check current row (just the ends, if they exist)
    if row_start < number_dict['start']:  # only check start if it exists
        if check_symbol(grid[row_idx][row_start]):
            return True
    if row_end > number_dict['end'] - 1:  # only check end if it exists
        if check_symbol(grid[row_idx][row_end]):
            return True
    
    # Check below row if it exists
    if row_idx < len(grid)-1:
        below = grid[row_idx+1][row_start:row_end+1]
        if check_symbol(below):
            return True
            
    return False
```

Would you like to try this updated version?

``` python
def has_adjacent_symbol(grid, row_idx, number_dict):
    row_length = len(grid[0])
    row_start = max(0, number_dict['start'] - 1)  # don't go below 0
    row_end = min(row_length - 1, number_dict['end'])  # don't go past last index
    
    # Check above row if it exists
    if row_idx > 0:
        above = grid[row_idx-1][row_start:row_end+1]
        if check_symbol(above):
            return True
    
    # Check current row (just the ends, if they exist)
    if row_start < number_dict['start']:  # only check start if it exists
        if check_symbol(grid[row_idx][row_start]):
            return True
    if row_end > number_dict['end'] - 1:  # only check end if it exists
        if check_symbol(grid[row_idx][row_end]):
            return True
    
    # Check below row if it exists
    if row_idx < len(grid)-1:
        below = grid[row_idx+1][row_start:row_end+1]
        if check_symbol(below):
            return True
            
    return False
```

``` python
nums=[]
for row_index, row in enumerate(xs):
    row_dicts = get_num_position(row)
    for row_dict in row_dicts:
        if has_adjacent_symbol(xs,row_index,row_dict):
            nums.append(row_dict['number'])

nums
```

    [467, 35, 633, 617, 592, 755, 664, 598]

**AI Prompt**

what’s the difference after the update? why it works now

**AI Response**

The key differences in the updated version that fixed the error are:

1.  Before: We were trying to access `grid[row_idx][row_end]` directly,
    which could be beyond the string length Now: We use
    `min(row_length - 1, number_dict['end'])` to ensure we never try to
    access beyond the string’s end

2.  Before: We checked both ends of the current row at once with tuple
    unpacking Now: We check each end separately with conditions:

    - `if row_start < number_dict['start']` - only check left edge if it
      exists
    - `if row_end > number_dict['end'] - 1` - only check right edge if
      it exists

Looking at the results: - Before: We got an IndexError - Now: We get
`[467, 35, 633, 617, 592, 755, 664, 598]` - Notice 114 and 58 are not
included (which is correct according to the puzzle rules - they’re not
adjacent to symbols)

Would you like to verify if this matches the expected answer from the
puzzle example?

``` python
from aocd import get_data
inp = get_data(day=2,year=2023)
```

``` python
xs = preprocess_raw(inp)
```

``` python
xs[:4]
```

    ['Game 1: 7 red, 14 blue; 2 blue, 3 red, 3 green; 4 green, 12 blue, 15 red; 3 green, 12 blue, 3 red; 11 red, 2 green',
     'Game 2: 16 blue, 9 red, 5 green; 8 red; 8 blue, 5 green, 12 red; 11 blue, 8 green, 17 red',
     'Game 3: 8 green, 1 blue, 7 red; 12 red, 6 blue, 9 green; 2 blue, 1 red, 14 green; 9 green, 4 red; 2 red, 1 blue, 8 green',
     'Game 4: 1 blue, 3 green; 2 green, 1 blue, 1 red; 1 red, 3 green']

``` python
from aocd import get_data
inp = get_data(day=3,year=2023)
xs = preprocess_raw(inp)
```

``` python
xs[:3]
```

    ['..............423....688..934............970................................95.728..........896...113..................153..972.............',
     '...122..................*.....*..........................919..509*..........&...@.........../...........................+.......*...........',
     '....+..........259....698..373.992.52.674.........................781...22........130.584.....-...%399.......777.................266........']

``` python
nums=[]
for row_index, row in enumerate(xs):
    row_dicts = get_num_position(row)
    for row_dict in row_dicts:
        if has_adjacent_symbol(xs,row_index,row_dict):
            nums.append(row_dict['number'])

sum(nums)
```

    538046

## Part 2

This time, you need to find the gear ratio of every gear and add them
all up so that the engineer can figure out which gear needs to be
replaced.

Consider the same engine schematic again:

    467..114..
    ...*......
    ..35..633.
    ......#...
    617*......
    .....+.58.
    ..592.....
    ......755.
    ...$.*....
    .664.598..

In this schematic, there are two gears. The first is in the top left; it
has part numbers 467 and 35, so its gear ratio is 16345. The second gear
is in the lower right; its gear ratio is 451490. (The \* adjacent to 617
is not a gear because it is only adjacent to one part number.) Adding up
all of the gear ratios produces 467835.

What is the sum of all of the gear ratios in your engine schematic?

``` python
467*35
```

    16345

``` python
755*598
```

    451490

``` python
16345+451490
```

    467835

``` python
get_num_position??
```

    Signature: get_num_position(row)
    Docstring: <no docstring>
    Source:   
    def get_num_position(row):
        dicts = []
        for match in re.finditer('\d+', row):
            number = int(match.group())  # the actual number
            start = match.start()        # starting position
            end = match.end()           # ending position
            dicts.append(dict(number=number,start=start,end=end))
        return dicts
    File:      ~/<ipython-input-1-b591f7575837>
    Type:      function

``` python
def get_star_positions(row):
    positions = []
    for position, char in enumerate(row):
        if char == "*":
            positions.append(position)
    return positions
```

``` python
get_star_positions('..*..*')
```

    [2, 5]

``` python
('..*..*').index('*')
```

    2

``` python
[o.index('*') for o in '..*..*']
```

    ---------------------------------------------------------------------------
    ValueError                                Traceback (most recent call last)
    Cell In[1], line 1
    ----> 1 [o.index('*') for o in '..*..*']

    Cell In[1], line 1, in <listcomp>(.0)
    ----> 1 [o.index('*') for o in '..*..*']

    ValueError: substring not found

    ValueError: substring not found
    Traceback (most recent call last):

      File "/usr/local/lib/python3.11/site-packages/IPython/core/interactiveshell.py", line 3577, in run_code
        exec(code_obj, self.user_global_ns, self.user_ns)

      File "<ipython-input-1-aba2ac0a35ed>", line 1, in <module>
        [o.index('*') for o in '..*..*']

      File "<ipython-input-1-aba2ac0a35ed>", line 1, in <listcomp>
        [o.index('*') for o in '..*..*']
         ^^^^^^^^^^^^

    ValueError: substring not found

``` python
for o in '..*..*': print(0)
```

    0
    0
    0
    0
    0
    0

``` python
for o in '..*..*': print(o)
```

    .
    .
    *
    .
    .
    *

``` python
def get_star_positions(row):
    return [index for index, val in enumerate(row) if val == '*']
```

``` python
get_star_positions(xs[1])
```

    [24, 30, 65, 128]

``` python
xs[1]
```

    '...122..................*.....*..........................919..509*..........&...@.........../...........................+.......*...........'

``` python
example = '''
467..114..
...*......
..35..633.
......#...
617*......
.....+.58.
..592.....
......755.
...$.*....
.664.598..
'''
```

``` python
xxs = preprocess_raw(example)
```

``` python
get_star_positions(xxs[1])
```

    [3]

**AI Prompt**

what’s next?

**AI Response**

For Part 2, we need to:

1.  Find all ’\*’ characters (potential gears) in each row
2.  For each ’\*’, check if it has exactly two adjacent numbers
3.  If it does, multiply those two numbers together to get the gear
    ratio
4.  Sum all the gear ratios

We’ve already got `get_star_positions` to find the ’\*’ locations. Now
we need to: 1. Write a function that finds all numbers adjacent to a
star at a given position 2. Check if there are exactly two numbers
adjacent to each star 3. Calculate and sum the gear ratios

Would you like to start by writing a function to find numbers adjacent
to a star at a given position? Or would you like some hints first?

**AI Prompt**

give me hints for this function

**AI Response**

Here’s how we can think about finding numbers adjacent to a star:

1.  For a star at position `star_pos` in row `row_idx`, we need to
    check:
    - The row above (row_idx - 1)
    - The current row (row_idx)
    - The row below (row_idx + 1)
2.  For each number in these rows (using `get_num_position`), check if
    it’s adjacent by:
    - Looking if any part of the number is within one position of the
      star
    - Example: if star is at position 3, check if the number’s positions
      overlap with positions 2-4
3.  We can test if a number overlaps these positions by checking if:
    - `number['start'] <= star_pos + 1` (number starts before or at the
      position after the star)
    - `number['end'] - 1 >= star_pos - 1` (number ends after or at the
      position before the star)

Would you like to try implementing this logic, or would you like more
specific hints?

**AI Prompt**

implement the logic

**AI Response**

Let’s write a function that finds numbers adjacent to a star. Try this:

``` python
def find_adjacent_numbers(grid, row_idx, star_pos):
    adjacent_numbers = []
    
    # Check the rows (above, current, and below)
    for check_row in range(max(0, row_idx-1), min(len(grid), row_idx+2)):
        numbers = get_num_position(grid[check_row])
        
        # For each number in the row, check if it's adjacent to the star
        for number in numbers:
            if (number['start'] <= star_pos + 1 and 
                number['end'] - 1 >= star_pos - 1):
                adjacent_numbers.append(number['number'])
                
    return adjacent_numbers
```

Would you like to test this function with our example data to see if it
correctly identifies the numbers adjacent to each star?

``` python
def find_adjacent_numbers(grid, row_idx, star_pos):
    adjacent_numbers = []
    
    # Check the rows (above, current, and below)
    for check_row in range(max(0, row_idx-1), min(len(grid), row_idx+2)):
        numbers = get_num_position(grid[check_row])
        
        # For each number in the row, check if it's adjacent to the star
        for number in numbers:
            if (number['start'] <= star_pos + 1 and 
                number['end'] - 1 >= star_pos - 1):
                adjacent_numbers.append(number['number'])
                
    return adjacent_numbers
```

``` python
all_nums = []
for row_idx, row in enumerate(xxs):
    star_poses = get_star_positions(row)
    for star_pos in star_poses:
        nums = find_adjacent_numbers(xxs,row_idx,star_pos)
        all_nums.append(nums)

all_nums
```

    [[467, 35], [617], [755, 598]]

``` python
all_nums = []
for row_idx, row in enumerate(xxs):
    star_poses = get_star_positions(row)
    for star_pos in star_poses:
        nums = find_adjacent_numbers(xxs,row_idx,star_pos)
        if len(nums) ==2:
            all_nums.append(nums)

all_nums
```

    [[467, 35], [755, 598]]

``` python
from math import prod
all_nums = []
for row_idx, row in enumerate(xxs):
    star_poses = get_star_positions(row)
    for star_pos in star_poses:
        nums = find_adjacent_numbers(xxs,row_idx,star_pos)
        if len(nums) ==2:
            all_nums.append(prod(nums))

all_nums
```

    [16345, 451490]

``` python
from math import prod
all_nums = []
for row_idx, row in enumerate(xs):
    star_poses = get_star_positions(row)
    for star_pos in star_poses:
        nums = find_adjacent_numbers(xs,row_idx,star_pos)
        if len(nums) ==2:
            all_nums.append(prod(nums))

sum(all_nums)
```

    81709807

**AI Prompt**

what’s this kind of usage “for number in numbers: if (number\[‘start’\]
\<= star_pos + 1 and number\[‘end’\] - 1 \>= star_pos - 1):
adjacent_numbers.append(number\[‘number’\])” I felt like amazing! is
this use common?

**AI Response**

Yes! This is a very common and powerful Python pattern that combines
several useful concepts:

1.  Dictionary access: Using `number['start']` and `number['end']` to
    access values in a dictionary
2.  Range comparison: Checking if a value falls within a range using two
    conditions:
    - `number['start'] <= star_pos + 1` (is it starting before or at our
      right boundary?)
    - `number['end'] - 1 >= star_pos - 1` (is it ending after or at our
      left boundary?)
3.  Multi-line conditions: Breaking a long condition across lines for
    readability using parentheses

This pattern is especially common when: - Working with positions or
ranges (like in games or text processing) - Checking for overlaps
between intervals - Processing geometric data

Would you like to see some other examples of how this pattern can be
used in different contexts?

**AI Prompt**

yes

**AI Response**

Here are some practical examples of similar patterns:

1.  Checking if two time periods overlap (like scheduling):

``` python
def has_time_conflict(meeting1, meeting2):
    return (meeting1['start_time'] <= meeting2['end_time'] and 
            meeting1['end_time'] >= meeting2['start_time'])
```

2.  Finding objects within a certain distance in a game:

``` python
def is_in_range(player, target):
    return (player['x'] - target['x'])**2 + (player['y'] - target['y'])**2 <= player['range']**2
```

Would you like to try using one of these patterns, or would you like to
see more examples? We could also explore how to use this pattern to
solve a specific problem you’re interested in.
